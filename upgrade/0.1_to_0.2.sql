CONNECT TO 'SAMPLE'!
SET SCHEMA UTILS!
SET PATH SYSTEM PATH, UTILS, USER!
CREATE ROLE UTILS_USER!
CREATE ROLE UTILS_ADMIN!
GRANT CREATEIN, ALTERIN, DROPIN ON SCHEMA UTILS TO ROLE UTILS_ADMIN WITH GRANT OPTION!
CREATE ROLE UTILS_SQL_USER!
CREATE ROLE UTILS_SQL_ADMIN!
GRANT ROLE UTILS_SQL_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_SQL_USER TO ROLE UTILS_SQL_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_SQL_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
GRANT EXECUTE ON SPECIFIC FUNCTION QUOTE_IDENTIFIER1 TO ROLE UTILS_SQL_USER!
GRANT EXECUTE ON SPECIFIC FUNCTION QUOTE_IDENTIFIER1 TO ROLE UTILS_SQL_ADMIN WITH GRANT OPTION!
COMMENT ON SPECIFIC FUNCTION QUOTE_IDENTIFIER1
    IS 'If AIDENT is an identifier which requires quoting, returns AIDENT surrounded by double quotes with all contained double quotes doubled. Useful when constructing SQL for EXECUTE IMMEDIATE within a procedure'!
CREATE ROLE UTILS_ASSERT_USER!
CREATE ROLE UTILS_ASSERT_ADMIN!
GRANT ROLE UTILS_ASSERT_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_ASSERT_USER TO ROLE UTILS_ASSERT_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_ASSERT_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
CREATE VARIABLE ASSERT_FAILED_STATE CHAR(5) CONSTANT '90001'!
GRANT READ ON VARIABLE ASSERT_FAILED_STATE TO ROLE UTILS_ASSERT_USER!
GRANT ALL ON VARIABLE ASSERT_FAILED_STATE TO ROLE UTILS_ASSERT_ADMIN WITH GRANT OPTION!
COMMENT ON VARIABLE ASSERT_FAILED_STATE
    IS 'The SQLSTATE raised by all ASSERT_* procedures and functions in the case the assertion fails'!
CREATE PROCEDURE SIGNAL_STATE(STATE CHAR(5), MESSAGE VARCHAR(70))
    SPECIFIC SIGNAL_STATE1
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
BEGIN
    SIGNAL SQLSTATE STATE SET MESSAGE_TEXT = MESSAGE;
END!
COMMENT ON SPECIFIC PROCEDURE SIGNAL_STATE1
    IS 'Simply wraps SIGNAL so that it can be used in triggers, EXECUTE IMMEDIATE statements, etc.'!
CREATE PROCEDURE ASSERT_SIGNALS(STATE CHAR(5), SQL CLOB(2M))
    SPECIFIC ASSERT_SIGNALS1
    LANGUAGE SQL
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
BEGIN ATOMIC
    DECLARE SQLSTATE CHAR(5);
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        IF SQLSTATE <> STATE THEN
            CALL SIGNAL_STATE(ASSERT_FAILED_STATE,
                SUBSTR(SQL, 1, 20)
                    || CASE WHEN LENGTH(SQL) > 20 THEN '...' ELSE '' END
                    || ' signalled SQLSTATE ' || SQLSTATE
                    || ' instead of ' || STATE);
        END IF;
    EXECUTE IMMEDIATE SQL;
    CALL SIGNAL_STATE(ASSERT_FAILED_STATE,
        SUBSTR(SQL, 1, 20)
            || CASE WHEN LENGTH(SQL) > 20 THEN '...' ELSE '' END
            || ' did not signal SQLSTATE ' || STATE);
END!
COMMENT ON SPECIFIC PROCEDURE ASSERT_SIGNALS1
    IS 'Signals ASSERT_FAILED_STATE if the execution of SQL doesn''t signal SQLSTATE STATE, or signals a different SQLSTATE'!
CREATE PROCEDURE ASSERT_TABLE_EXISTS(ASCHEMA VARCHAR(128), ATABLE VARCHAR(128))
    SPECIFIC ASSERT_TABLE_EXISTS1
    LANGUAGE SQL
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
BEGIN ATOMIC
    IF (
            SELECT COUNT(*)
            FROM SYSCAT.TABLES
            WHERE TABSCHEMA = ASCHEMA
            AND TABNAME = ATABLE
        ) = 0 THEN
        CALL SIGNAL_STATE(ASSERT_FAILED_STATE, SUBSTR(ASCHEMA || '.' || ATABLE, 1, 50)
            || CASE WHEN LENGTH(ASCHEMA) + 1 + LENGTH(ATABLE) > 50 THEN '...' ELSE '' END
            || ' does not exist');
    END IF;
END!
CREATE PROCEDURE ASSERT_TABLE_EXISTS(ATABLE VARCHAR(128))
    SPECIFIC ASSERT_TABLE_EXISTS2
    LANGUAGE SQL
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
BEGIN ATOMIC
    CALL ASSERT_TABLE_EXISTS(CURRENT SCHEMA, ATABLE);
END!
COMMENT ON SPECIFIC PROCEDURE ASSERT_TABLE_EXISTS1
    IS 'Signals ASSERT_FAILED_STATE if the specified table does not exist'!
COMMENT ON SPECIFIC PROCEDURE ASSERT_TABLE_EXISTS2
    IS 'Signals ASSERT_FAILED_STATE if the specified table does not exist'!
CREATE PROCEDURE ASSERT_COLUMN_EXISTS(
        ASCHEMA VARCHAR(128),
        ATABLE VARCHAR(128),
        ACOLNAME VARCHAR(128)
    )
    SPECIFIC ASSERT_COLUMN_EXISTS1
    LANGUAGE SQL
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
BEGIN ATOMIC
    IF (
            SELECT COUNT(*)
            FROM SYSCAT.COLUMNS
            WHERE TABSCHEMA = ASCHEMA
            AND TABNAME = ATABLE
            AND COLNAME = ACOLNAME
        ) = 0 THEN
        CALL SIGNAL_STATE(ASSERT_FAILED_STATE, SUBSTR(ACOLNAME, 1, 20)
            || CASE WHEN LENGTH(ACOLNAME) > 20 THEN '...' ELSE '' END
            || ' does not exist in '
            || SUBSTR(ASCHEMA || '.' || ATABLE, 1, 30)
            || CASE WHEN LENGTH(ASCHEMA) + 1 + LENGTH(ATABLE) > 30 THEN '...' ELSE '' END);
    END IF;
END!
CREATE PROCEDURE ASSERT_COLUMN_EXISTS(ATABLE VARCHAR(128), ACOLNAME VARCHAR(128))
    SPECIFIC ASSERT_COLUMN_EXISTS2
    LANGUAGE SQL
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
BEGIN ATOMIC
    CALL ASSERT_COLUMN_EXISTS(CURRENT SCHEMA, ATABLE, ACOLNAME);
END!
COMMENT ON SPECIFIC PROCEDURE ASSERT_COLUMN_EXISTS1
    IS 'Signals ASSERT_FAILED_STATE if the specified column does not exist'!
COMMENT ON SPECIFIC PROCEDURE ASSERT_COLUMN_EXISTS2
    IS 'Signals ASSERT_FAILED_STATE if the specified column does not exist'!
CREATE PROCEDURE ASSERT_TRIGGER_EXISTS(ASCHEMA VARCHAR(128), ATRIGGER VARCHAR(128))
    SPECIFIC ASSERT_TRIGGER_EXISTS1
    LANGUAGE SQL
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
BEGIN ATOMIC
    IF (
            SELECT COUNT(*)
            FROM SYSCAT.TRIGGERS
            WHERE TRIGSCHEMA = ASCHEMA
            AND TRIGNAME = ATRIGGER
        ) = 0 THEN
        CALL SIGNAL_STATE(ASSERT_FAILED_STATE, SUBSTR(ASCHEMA || '.' || ATRIGGER, 1, 50)
            || CASE WHEN LENGTH(ASCHEMA) + 1 + LENGTH(ATRIGGER) > 50 THEN '...' ELSE '' END
            || ' does not exist');
    END IF;
END!
CREATE PROCEDURE ASSERT_TRIGGER_EXISTS(ATRIGGER VARCHAR(128))
    SPECIFIC ASSERT_TRIGGER_EXISTS2
    LANGUAGE SQL
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
BEGIN ATOMIC
    CALL ASSERT_TRIGGER_EXISTS(CURRENT SCHEMA, ATRIGGER);
END!
COMMENT ON SPECIFIC PROCEDURE ASSERT_TRIGGER_EXISTS1
    IS 'Signals ASSERT_FAILED_STATE if the specified trigger does not exist'!
COMMENT ON SPECIFIC PROCEDURE ASSERT_TRIGGER_EXISTS2
    IS 'Signals ASSERT_FAILED_STATE if the specified trigger does not exist'!
CREATE PROCEDURE ASSERT_ROUTINE_EXISTS(ASCHEMA VARCHAR(128), AROUTINE VARCHAR(128))
    SPECIFIC ASSERT_ROUTINE_EXISTS1
    LANGUAGE SQL
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
BEGIN ATOMIC
    IF (
            SELECT COUNT(*)
            FROM SYSCAT.ROUTINES
            WHERE ROUTINESCHEMA = ASCHEMA
            AND ROUTINENAME = AROUTINE
        ) = 0 THEN
        CALL SIGNAL_STATE(ASSERT_FAILED_STATE, SUBSTR(ASCHEMA || '.' || AROUTINE, 1, 50)
            || CASE WHEN LENGTH(ASCHEMA) + 1 + LENGTH(AROUTINE) > 50 THEN '...' ELSE '' END
            || ' does not exist');
    END IF;
END!
CREATE PROCEDURE ASSERT_ROUTINE_EXISTS(AROUTINE VARCHAR(128))
    SPECIFIC ASSERT_ROUTINE_EXISTS2
    LANGUAGE SQL
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
BEGIN ATOMIC
    CALL ASSERT_ROUTINE_EXISTS(CURRENT SCHEMA, AROUTINE);
END!
COMMENT ON SPECIFIC PROCEDURE ASSERT_ROUTINE_EXISTS1
    IS 'Signals ASSERT_FAILED_STATE if the specified routine does not exist'!
COMMENT ON SPECIFIC PROCEDURE ASSERT_ROUTINE_EXISTS2
    IS 'Signals ASSERT_FAILED_STATE if the specified routine does not exist'!
CREATE FUNCTION ASSERT_IS_NULL(A INTEGER)
    RETURNS INTEGER
    SPECIFIC ASSERT_IS_NULL1
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE WHEN A IS NULL
        THEN 0
        ELSE RAISE_ERROR(ASSERT_FAILED_STATE, VARCHAR(A) || ' is non-NULL')
    END!
CREATE FUNCTION ASSERT_IS_NULL(A DOUBLE)
    RETURNS INTEGER
    SPECIFIC ASSERT_IS_NULL2
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE WHEN A IS NULL
        THEN 0
        ELSE RAISE_ERROR(ASSERT_FAILED_STATE, VARCHAR(A) || ' is non-NULL')
    END!
CREATE FUNCTION ASSERT_IS_NULL(A TIMESTAMP)
    RETURNS INTEGER
    SPECIFIC ASSERT_IS_NULL3
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE WHEN A IS NULL
        THEN 0
        ELSE RAISE_ERROR(ASSERT_FAILED_STATE, VARCHAR(A) || ' is non-NULL')
    END!
CREATE FUNCTION ASSERT_IS_NULL(A TIME)
    RETURNS INTEGER
    SPECIFIC ASSERT_IS_NULL4
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE WHEN A IS NULL
        THEN 0
        ELSE RAISE_ERROR(ASSERT_FAILED_STATE, VARCHAR(A) || ' is non-NULL')
    END!
CREATE FUNCTION ASSERT_IS_NULL(A VARCHAR(4000))
    RETURNS INTEGER
    SPECIFIC ASSERT_IS_NULL5
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE WHEN A IS NULL
        THEN 0
        ELSE RAISE_ERROR(ASSERT_FAILED_STATE,
            QUOTE_STRING(SUBSTR(A, 1, 20) || CASE WHEN LENGTH(A) > 20 THEN '...' ELSE '' END) ||
            ' is non-NULL')
    END!
COMMENT ON SPECIFIC FUNCTION ASSERT_IS_NULL1
    IS 'Signals ASSERT_FAILED_STATE if the specified value is not NULL'!
COMMENT ON SPECIFIC FUNCTION ASSERT_IS_NULL2
    IS 'Signals ASSERT_FAILED_STATE if the specified value is not NULL'!
COMMENT ON SPECIFIC FUNCTION ASSERT_IS_NULL3
    IS 'Signals ASSERT_FAILED_STATE if the specified value is not NULL'!
COMMENT ON SPECIFIC FUNCTION ASSERT_IS_NULL4
    IS 'Signals ASSERT_FAILED_STATE if the specified value is not NULL'!
COMMENT ON SPECIFIC FUNCTION ASSERT_IS_NULL5
    IS 'Signals ASSERT_FAILED_STATE if the specified value is not NULL'!
CREATE FUNCTION ASSERT_IS_NOT_NULL(A INTEGER)
    RETURNS INTEGER
    SPECIFIC ASSERT_IS_NOT_NULL1
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE WHEN A IS NULL
        THEN RAISE_ERROR(ASSERT_FAILED_STATE, 'Value is NULL')
        ELSE 0
    END!
CREATE FUNCTION ASSERT_IS_NOT_NULL(A DOUBLE)
    RETURNS INTEGER
    SPECIFIC ASSERT_IS_NOT_NULL2
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE WHEN A IS NULL
        THEN RAISE_ERROR(ASSERT_FAILED_STATE, 'Value is NULL')
        ELSE 0
    END!
CREATE FUNCTION ASSERT_IS_NOT_NULL(A TIMESTAMP)
    RETURNS INTEGER
    SPECIFIC ASSERT_IS_NOT_NULL3
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE WHEN A IS NULL
        THEN RAISE_ERROR(ASSERT_FAILED_STATE, 'Value is NULL')
        ELSE 0
    END!
CREATE FUNCTION ASSERT_IS_NOT_NULL(A TIME)
    RETURNS INTEGER
    SPECIFIC ASSERT_IS_NOT_NULL4
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE WHEN A IS NULL
        THEN RAISE_ERROR(ASSERT_FAILED_STATE, 'Value is NULL')
        ELSE 0
    END!
CREATE FUNCTION ASSERT_IS_NOT_NULL(A VARCHAR(4000))
    RETURNS INTEGER
    SPECIFIC ASSERT_IS_NOT_NULL5
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE WHEN A IS NULL
        THEN RAISE_ERROR(ASSERT_FAILED_STATE, 'Value is NULL')
        ELSE 0
    END!
COMMENT ON SPECIFIC FUNCTION ASSERT_IS_NOT_NULL1
    IS 'Signals ASSERT_FAILED_STATE if the specified value is NULL'!
COMMENT ON SPECIFIC FUNCTION ASSERT_IS_NOT_NULL2
    IS 'Signals ASSERT_FAILED_STATE if the specified value is NULL'!
COMMENT ON SPECIFIC FUNCTION ASSERT_IS_NOT_NULL3
    IS 'Signals ASSERT_FAILED_STATE if the specified value is NULL'!
COMMENT ON SPECIFIC FUNCTION ASSERT_IS_NOT_NULL4
    IS 'Signals ASSERT_FAILED_STATE if the specified value is NULL'!
COMMENT ON SPECIFIC FUNCTION ASSERT_IS_NOT_NULL5
    IS 'Signals ASSERT_FAILED_STATE if the specified value is NULL'!
CREATE FUNCTION ASSERT_EQUALS(A INTEGER, B INTEGER)
    RETURNS INTEGER
    SPECIFIC ASSERT_EQUALS1
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE A
        WHEN B THEN 0
        ELSE RAISE_ERROR(ASSERT_FAILED_STATE, VARCHAR(A) || ' does not equal ' || VARCHAR(B))
    END!
CREATE FUNCTION ASSERT_EQUALS(A DOUBLE, B DOUBLE)
    RETURNS INTEGER
    SPECIFIC ASSERT_EQUALS2
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE A
        WHEN B THEN 0
        ELSE RAISE_ERROR(ASSERT_FAILED_STATE, VARCHAR(A) || ' does not equal ' || VARCHAR(B))
    END!
CREATE FUNCTION ASSERT_EQUALS(A TIMESTAMP, B TIMESTAMP)
    RETURNS INTEGER
    SPECIFIC ASSERT_EQUALS3
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE A
        WHEN B THEN 0
        ELSE RAISE_ERROR(ASSERT_FAILED_STATE, VARCHAR_FORMAT(A) || ' does not equal ' || VARCHAR_FORMAT(B))
    END!
CREATE FUNCTION ASSERT_EQUALS(A TIME, B TIME)
    RETURNS INTEGER
    SPECIFIC ASSERT_EQUALS4
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE A
        WHEN B THEN 0
        ELSE RAISE_ERROR(ASSERT_FAILED_STATE, VARCHAR(A) || ' does not equal ' || VARCHAR(B))
    END!
CREATE FUNCTION ASSERT_EQUALS(A VARCHAR(4000), B VARCHAR(4000))
    RETURNS INTEGER
    SPECIFIC ASSERT_EQUALS5
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE A
        WHEN B THEN 0
        ELSE RAISE_ERROR(ASSERT_FAILED_STATE,
            QUOTE_STRING(SUBSTR(A, 1, 20) || CASE WHEN LENGTH(A) > 20 THEN '...' ELSE '' END) ||
            ' does not equal ' ||
            QUOTE_STRING(SUBSTR(B, 1, 20) || CASE WHEN LENGTH(B) > 20 THEN '...' ELSE '' END))
    END!
COMMENT ON SPECIFIC FUNCTION ASSERT_EQUALS1
    IS 'Signals ASSERT_FAILED_STATE if A does not equal B'!
COMMENT ON SPECIFIC FUNCTION ASSERT_EQUALS2
    IS 'Signals ASSERT_FAILED_STATE if A does not equal B'!
COMMENT ON SPECIFIC FUNCTION ASSERT_EQUALS3
    IS 'Signals ASSERT_FAILED_STATE if A does not equal B'!
COMMENT ON SPECIFIC FUNCTION ASSERT_EQUALS4
    IS 'Signals ASSERT_FAILED_STATE if A does not equal B'!
COMMENT ON SPECIFIC FUNCTION ASSERT_EQUALS5
    IS 'Signals ASSERT_FAILED_STATE if A does not equal B'!
CREATE FUNCTION ASSERT_NOT_EQUALS(A INTEGER, B INTEGER)
    RETURNS INTEGER
    SPECIFIC ASSERT_NOT_EQUALS1
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE A
        WHEN B THEN RAISE_ERROR(ASSERT_FAILED_STATE, 'Values are both ' || VARCHAR(A))
        ELSE 0
    END!
CREATE FUNCTION ASSERT_NOT_EQUALS(A DOUBLE, B DOUBLE)
    RETURNS INTEGER
    SPECIFIC ASSERT_NOT_EQUALS2
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE A
        WHEN B THEN RAISE_ERROR(ASSERT_FAILED_STATE, 'Values are both ' || VARCHAR(A))
        ELSE 0
    END!
CREATE FUNCTION ASSERT_NOT_EQUALS(A TIMESTAMP, B TIMESTAMP)
    RETURNS INTEGER
    SPECIFIC ASSERT_NOT_EQUALS3
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE A
        WHEN B THEN RAISE_ERROR(ASSERT_FAILED_STATE, 'Values are both ' || VARCHAR_FORMAT(A))
        ELSE 0
    END!
CREATE FUNCTION ASSERT_NOT_EQUALS(A TIME, B TIME)
    RETURNS INTEGER
    SPECIFIC ASSERT_NOT_EQUALS4
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE A
        WHEN B THEN RAISE_ERROR(ASSERT_FAILED_STATE, 'Values are both ' || VARCHAR(A))
        ELSE 0
    END!
CREATE FUNCTION ASSERT_NOT_EQUALS(A VARCHAR(4000), B VARCHAR(4000))
    RETURNS INTEGER
    SPECIFIC ASSERT_NOT_EQUALS5
    LANGUAGE SQL
    CONTAINS SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
RETURN
    CASE A
        WHEN B THEN RAISE_ERROR(ASSERT_FAILED_STATE,
            'Values are both '
            || QUOTE_STRING(SUBSTR(A, 1, 40)
            || CASE WHEN LENGTH(A) > 40 THEN '...' ELSE '' END))
        ELSE 0
    END!
GRANT EXECUTE ON SPECIFIC FUNCTION ASSERT_NOT_EQUALS5 TO ROLE UTILS_ASSERT_USER!
GRANT EXECUTE ON SPECIFIC FUNCTION ASSERT_NOT_EQUALS5 TO ROLE UTILS_ASSERT_ADMIN WITH GRANT OPTION!
COMMENT ON SPECIFIC FUNCTION ASSERT_NOT_EQUALS1
    IS 'Signals ASSERT_FAILED_STATE if A equals B'!
COMMENT ON SPECIFIC FUNCTION ASSERT_NOT_EQUALS2
    IS 'Signals ASSERT_FAILED_STATE if A equals B'!
COMMENT ON SPECIFIC FUNCTION ASSERT_NOT_EQUALS3
    IS 'Signals ASSERT_FAILED_STATE if A equals B'!
COMMENT ON SPECIFIC FUNCTION ASSERT_NOT_EQUALS4
    IS 'Signals ASSERT_FAILED_STATE if A equals B'!
COMMENT ON SPECIFIC FUNCTION ASSERT_NOT_EQUALS5
    IS 'Signals ASSERT_FAILED_STATE if A equals B'!
CREATE ROLE UTILS_AUTH_USER!
CREATE ROLE UTILS_AUTH_ADMIN!
GRANT ROLE UTILS_AUTH_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_AUTH_USER TO ROLE UTILS_AUTH_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_AUTH_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
CREATE VARIABLE AUTH_AMBIGUOUS_STATE CHAR(5) CONSTANT '90002'!
GRANT READ ON VARIABLE AUTH_AMBIGUOUS_STATE TO ROLE UTILS_AUTH_USER!
GRANT ALL ON VARIABLE AUTH_AMBIGUOUS_STATE TO ROLE UTILS_AUTH_ADMIN WITH GRANT OPTION!
COMMENT ON VARIABLE AUTH_AMBIGUOUS_STATE
    IS 'The SQLSTATE raised when an authentication type is ambiguous (e.g. refers to both a user & group)'!
CREATE FUNCTION X_COPY_LIST(
    SOURCE VARCHAR(128),
    SOURCE_TYPE VARCHAR(1),
    DEST VARCHAR(128),
    DEST_TYPE VARCHAR(1),
    INCLUDE_PERSONAL VARCHAR(1)
)
    RETURNS TABLE (
        OBJECT_TYPE VARCHAR(18),
        OBJECT_ID VARCHAR(262),
        DDL VARCHAR(2000)
    )
    SPECIFIC X_COPY_LIST
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
    LANGUAGE SQL
RETURN
    SELECT
        OBJECT_TYPE,
        OBJECT_ID,
        'GRANT ' || AUTH ||
        CASE OBJECT_TYPE
            WHEN '' THEN ''
            ELSE
                CASE OBJECT_TYPE
                    WHEN 'TABLESPACE' THEN ' OF '
                    ELSE ' ON '
                END || OBJECT_TYPE || ' ' || OBJECT_ID
        END || ' TO ' ||
        CASE DEST_TYPE
            WHEN 'U' THEN 'USER ' || QUOTE_IDENTIFIER(DEST)
            WHEN 'R' THEN 'ROLE ' || QUOTE_IDENTIFIER(DEST)
            WHEN 'G' THEN
                CASE DEST
                    WHEN 'PUBLIC' THEN DEST
                    ELSE 'GROUP ' || QUOTE_IDENTIFIER(DEST)
                END
        END || ' ' || SUFFIX AS DDL
    FROM
        TABLE(AUTH_DIFF(
            SOURCE,
            SOURCE_TYPE,
            DEST,
            DEST_TYPE,
            CHAR('Y'),
            INCLUDE_PERSONAL
        )) AS T!
CREATE FUNCTION X_REMOVE_LIST(
    AUTH_NAME VARCHAR(128),
    AUTH_TYPE VARCHAR(1),
    INCLUDE_PERSONAL VARCHAR(1)
)
    RETURNS TABLE (
        OBJECT_TYPE VARCHAR(18),
        OBJECT_ID VARCHAR(262),
        AUTH VARCHAR(140),
        DDL VARCHAR(2000)
    )
    SPECIFIC X_REMOVE_LIST
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
    LANGUAGE SQL
RETURN
    SELECT
        OBJECT_TYPE,
        OBJECT_ID,
        AUTH,
        'REVOKE ' || AUTH ||
        CASE OBJECT_TYPE
            WHEN '' THEN ''
            ELSE
                CASE OBJECT_TYPE
                    WHEN 'TABLESPACE' THEN ' OF '
                    ELSE ' ON '
                END || OBJECT_TYPE || ' ' || OBJECT_ID
        END || ' FROM ' ||
        CASE AUTH_TYPE
            WHEN 'U' THEN 'USER ' || QUOTE_IDENTIFIER(AUTH_NAME)
            WHEN 'R' THEN 'ROLE ' || QUOTE_IDENTIFIER(AUTH_NAME)
            WHEN 'G' THEN
                CASE AUTH_NAME
                    WHEN 'PUBLIC' THEN AUTH_NAME
                    ELSE 'GROUP ' || QUOTE_IDENTIFIER(AUTH_NAME)
                END
        END || ' ' ||
        CASE OBJECT_TYPE
            WHEN 'SPECIFIC FUNCTION'  THEN 'RESTRICT'
            WHEN 'SPECIFIC PROCEDURE' THEN 'RESTRICT'
            WHEN 'FUNCTION'           THEN 'RESTRICT'
            WHEN 'PROCEDURE'          THEN 'RESTRICT'
            ELSE ''
        END AS DDL
    FROM
        TABLE(AUTHS_HELD(
            AUTH_NAME,
            AUTH_TYPE,
            'N',
            INCLUDE_PERSONAL
        )) AS T!
GRANT CONTROL ON TABLE SAVED_AUTH TO ROLE UTILS_AUTH_ADMIN WITH GRANT OPTION!
GRANT EXECUTE ON SPECIFIC PROCEDURE RESTORE_AUTHS2 TO ROLE UTILS_AUTH_USER!
GRANT EXECUTE ON SPECIFIC PROCEDURE RESTORE_AUTHS2 TO ROLE UTILS_AUTH_ADMIN WITH GRANT OPTION!
CREATE ROLE UTILS_LOG_READER!
CREATE ROLE UTILS_LOG_WRITER!
CREATE ROLE UTILS_LOG_ADMIN!
GRANT ROLE UTILS_LOG_READER TO ROLE UTILS_USER!
GRANT ROLE UTILS_LOG_WRITER TO ROLE UTILS_USER!
GRANT ROLE UTILS_LOG_READER TO ROLE UTILS_LOG_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_LOG_WRITER TO ROLE UTILS_LOG_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_LOG_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
GRANT EXECUTE ON SPECIFIC FUNCTION VARCHAR_EXPRESSION2 TO ROLE UTILS_LOG_ADMIN WITH GRANT OPTION!
GRANT CONTROL ON TABLE LOG TO ROLE UTILS_LOG_ADMIN!
GRANT SELECT ON TABLE LOG TO ROLE UTILS_LOG_READER!
GRANT INSERT ON TABLE LOG TO ROLE UTILS_LOG_WRITER!
CREATE ROLE UTILS_CORRECTIONS_USER!
CREATE ROLE UTILS_CORRECTIONS_ADMIN!
GRANT ROLE UTILS_CORRECTIONS_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_CORRECTIONS_USER TO ROLE UTILS_CORRECTIONS_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_CORRECTIONS_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
GRANT EXECUTE ON SPECIFIC PROCEDURE CREATE_CORRECTION_TRIGGERS2 TO ROLE UTILS_CORRECTIONS_USER!
GRANT EXECUTE ON SPECIFIC PROCEDURE CREATE_CORRECTION_TRIGGERS2 TO ROLE UTILS_CORRECTIONS_ADMIN WITH GRANT OPTION!
CREATE ROLE UTILS_DATE_TIME_USER!
CREATE ROLE UTILS_DATE_TIME_ADMIN!
GRANT ROLE UTILS_DATE_TIME_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_DATE_TIME_USER TO ROLE UTILS_DATE_TIME_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_DATE_TIME_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
CREATE VARIABLE VACATION_WEEKEND_STATE CHAR(5) CONSTANT '90003'!
COMMENT ON VARIABLE VACATION_WEEKEND_STATE
    IS 'The SQLSTATE raised when an attempt is made to define a weekend as a vacation'!
CREATE FUNCTION X_TS_PAD(VALUE VARCHAR(11), MINLEN INTEGER, PAD VARCHAR(1))
    RETURNS VARCHAR(100)
    SPECIFIC X_TS_PAD
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    CASE WHEN LENGTH(VALUE) < MINLEN
        THEN REPEAT(PAD, MINLEN - LENGTH(VALUE)) || VALUE
        ELSE VALUE
    END!
CREATE FUNCTION X_TS_FMT(VALUE INTEGER, FLAGS VARCHAR(5), MINLEN INTEGER, PAD VARCHAR(1))
    RETURNS VARCHAR(100)
    SPECIFIC X_TS_FMT
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    X_TS_PAD(RTRIM(CHAR(VALUE)), MINLEN,
        CASE
            WHEN POSSTR(FLAGS, '_') > 0 THEN ' '
            WHEN POSSTR(FLAGS, '0') > 0 THEN '0'
            WHEN POSSTR(FLAGS, '-') > 0 THEN ''
            ELSE PAD
        END)!
COMMENT ON SPECIFIC FUNCTION X_TS_PAD
    IS 'Internal utility sub-routine for TS_FORMAT'!
COMMENT ON SPECIFIC FUNCTION X_TS_FMT
    IS 'Internal utility sub-routine for TS_FORMAT'!
GRANT CONTROL ON TABLE VACATIONS TO ROLE UTILS_DATE_TIME_ADMIN WITH GRANT OPTION!
CREATE FUNCTION X_WORKINGDAY_DAY(ADATE DATE, RELATIVE_TO DATE)
    RETURNS INTEGER
    SPECIFIC X_WORKINGDAY_DAY
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    DAYS(ADATE) - DAYS(RELATIVE_TO) + 1!
CREATE FUNCTION X_WORKINGDAY_SDOW(RELATIVE_TO DATE)
    RETURNS INTEGER
    SPECIFIC X_WORKINGDAY_SDOW
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    DAYOFWEEK_ISO(RELATIVE_TO)!
GRANT EXECUTE ON SPECIFIC FUNCTION WORKINGDAY4 TO ROLE UTILS_DATE_TIME_USER!
GRANT EXECUTE ON SPECIFIC FUNCTION WORKINGDAY4 TO ROLE UTILS_DATE_TIME_ADMIN WITH GRANT OPTION!
CREATE ROLE UTILS_DROP_SCHEMA_USER!
CREATE ROLE UTILS_DROP_SCHEMA_ADMIN!
GRANT ROLE UTILS_DROP_SCHEMA_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_DROP_SCHEMA_USER TO ROLE UTILS_DROP_SCHEMA_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_DROP_SCHEMA_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
CREATE FUNCTION X_DROP_LIST(ASCHEMA VARCHAR(128))
    RETURNS TABLE(
        CREATE_TIME TIMESTAMP,
        DDL    VARCHAR(1000)
    )
    SPECIFIC X_DROP_LIST
    READS SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
RETURN
    WITH DROP_LIST (CREATE_TIME, SCHEMA_NAME, DDL) AS (
        SELECT
            CREATE_TIME,
            TABSCHEMA AS SCHEMA_NAME,
            'DROP ' || CASE TYPE
                WHEN 'A' THEN 'ALIAS'
                WHEN 'H' THEN 'TABLE'
                WHEN 'N' THEN 'NICKNAME'
                WHEN 'S' THEN 'TABLE'
                WHEN 'T' THEN 'TABLE'
                WHEN 'U' THEN 'TABLE'
                WHEN 'V' THEN 'VIEW'
                WHEN 'W' THEN 'VIEW'
            END || ' ' || QUOTE_IDENTIFIER(TABSCHEMA) || '.' || QUOTE_IDENTIFIER(TABNAME) AS DDL
        FROM SYSCAT.TABLES
        UNION
        SELECT
            CREATE_TIME,
            TRIGSCHEMA AS SCHEMA_NAME,
            'DROP TRIGGER ' || QUOTE_IDENTIFIER(TRIGSCHEMA) || '.' || QUOTE_IDENTIFIER(TRIGNAME) AS DDL
        FROM SYSCAT.TRIGGERS
        UNION
        SELECT
            CREATE_TIME,
            ROUTINESCHEMA AS SCHEMA_NAME,
            'DROP ' || CASE ROUTINETYPE
                WHEN 'F' THEN 'SPECIFIC FUNCTION'
                WHEN 'M' THEN 'SPECIFIC METHOD'
                WHEN 'P' THEN 'SPECIFIC PROCEDURE'
            END || ' ' || QUOTE_IDENTIFIER(ROUTINESCHEMA) || '.' || QUOTE_IDENTIFIER(SPECIFICNAME) AS DDL
        FROM SYSCAT.ROUTINES
        UNION
        SELECT
            CREATE_TIME,
            TYPESCHEMA AS SCHEMA_NAME,
            'DROP TYPE ' || QUOTE_IDENTIFIER(TYPESCHEMA) || '.' || QUOTE_IDENTIFIER(TYPENAME) AS DDL
        FROM SYSCAT.DATATYPES
        UNION
        SELECT
            CREATE_TIME,
            SEQSCHEMA AS SCHEMA_NAME,
            'DROP SEQUENCE ' || QUOTE_IDENTIFIER(SEQSCHEMA) || '.' || QUOTE_IDENTIFIER(SEQNAME) AS DDL
        FROM SYSCAT.SEQUENCES
        UNION
        SELECT
            CREATE_TIME,
            SCHEMANAME AS SCHEMA_NAME,
            'DROP SCHEMA ' || QUOTE_IDENTIFIER(SCHEMANAME) || ' RESTRICT' AS DDL
        FROM SYSCAT.SCHEMATA
    )
    SELECT CREATE_TIME, DDL
    FROM DROP_LIST
    WHERE SCHEMA_NAME = ASCHEMA!
GRANT EXECUTE ON SPECIFIC PROCEDURE DROP_SCHEMA1 TO ROLE UTILS_DROP_SCHEMA_USER!
GRANT EXECUTE ON SPECIFIC PROCEDURE DROP_SCHEMA1 TO ROLE UTILS_DROP_SCHEMA_ADMIN WITH GRANT OPTION!
CREATE ROLE UTILS_EVOLVE_USER!
CREATE ROLE UTILS_EVOLVE_ADMIN!
GRANT ROLE UTILS_EVOLVE_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_EVOLVE_USER TO ROLE UTILS_EVOLVE_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_EVOLVE_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
GRANT CONTROL ON TABLE SAVED_VIEWS TO ROLE UTILS_EVOLVE_ADMIN WITH GRANT OPTION!
CREATE ROLE UTILS_EXCEPTIONS_USER!
CREATE ROLE UTILS_EXCEPTIONS_ADMIN!
GRANT ROLE UTILS_EXCEPTIONS_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_EXCEPTIONS_USER TO ROLE UTILS_EXCEPTIONS_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_EXCEPTIONS_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
GRANT EXECUTE ON SPECIFIC PROCEDURE CREATE_EXCEPTION_VIEW3 TO ROLE UTILS_EVOLVE_USER!
GRANT EXECUTE ON SPECIFIC PROCEDURE CREATE_EXCEPTION_VIEW3 TO ROLE UTILS_EVOLVE_ADMIN WITH GRANT OPTION!
CREATE ROLE UTILS_LOAD_USER!
CREATE ROLE UTILS_LOAD_ADMIN!
GRANT ROLE UTILS_LOAD_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_LOAD_USER TO ROLE UTILS_LOAD_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_LOAD_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
GRANT EXECUTE ON SPECIFIC FUNCTION LOAD_SCHEMA3 TO ROLE UTILS_LOAD_USER!
GRANT EXECUTE ON SPECIFIC FUNCTION LOAD_SCHEMA3 TO ROLE UTILS_LOAD_ADMIN WITH GRANT OPTION!
CREATE ROLE UTILS_HISTORY_USER!
CREATE ROLE UTILS_HISTORY_ADMIN!
GRANT ROLE UTILS_HISTORY_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_HISTORY_USER TO ROLE UTILS_HISTORY_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_HISTORY_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
CREATE VARIABLE HISTORY_KEY_FIELDS_STATE CHAR(5) CONSTANT '90004'!
CREATE VARIABLE HISTORY_NO_PK_STATE CHAR(5) CONSTANT '90005'!
CREATE VARIABLE HISTORY_UPDATE_PK_STATE CHAR(5) CONSTANT '90006'!
GRANT READ ON VARIABLE HISTORY_KEY_FIELDS_STATE TO ROLE UTILS_HISTORY_USER!
GRANT READ ON VARIABLE HISTORY_NO_PK_STATE TO ROLE UTILS_HISTORY_USER!
GRANT READ ON VARIABLE HISTORY_UPDATE_PK_STATE TO ROLE UTILS_HISTORY_USER!
GRANT READ ON VARIABLE HISTORY_KEY_FIELDS_STATE TO ROLE UTILS_HISTORY_ADMIN WITH GRANT OPTION!
GRANT READ ON VARIABLE HISTORY_NO_PK_STATE TO ROLE UTILS_HISTORY_ADMIN WITH GRANT OPTION!
GRANT READ ON VARIABLE HISTORY_UPDATE_PK_STATE TO ROLE UTILS_HISTORY_ADMIN WITH GRANT OPTION!
COMMENT ON VARIABLE HISTORY_KEY_FIELDS_STATE
    IS 'The SQLSTATE raised when a history sub-routine is called with something other than ''Y'' or ''N'' as the KEY_FIELDS parameter'!
COMMENT ON VARIABLE HISTORY_NO_PK_STATE
    IS 'The SQLSTATE raised when an attempt is made to create a history table for a table without a primary key'!
COMMENT ON VARIABLE HISTORY_UPDATE_PK_STATE
    IS 'The SQLSTATE raised when an attempt is made to update a primary key''s value in a table with an associated history table'!
CREATE FUNCTION X_HISTORY_EFFNAME(RESOLUTION VARCHAR(11))
    RETURNS VARCHAR(30)
    SPECIFIC X_HISTORY_EFFNAME1
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    CASE WHEN RESOLUTION IN (
            'MICROSECOND',
            'SECOND',
            'MINUTE',
            'HOUR',
            'DAY',
            'WEEK',
            'WEEK_ISO',
            'MONTH',
            'YEAR'
        )
        THEN 'EFFECTIVE_' || RESOLUTION
        ELSE RAISE_ERROR('70001', 'Invalid RESOLUTION value ' || RESOLUTION)
    END!
CREATE FUNCTION X_HISTORY_EFFNAME(SOURCE_SCHEMA VARCHAR(128), SOURCE_TABLE VARCHAR(128))
    RETURNS VARCHAR(128)
    SPECIFIC X_HISTORY_EFFNAME2
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
RETURN
    SELECT COLNAME
    FROM SYSCAT.COLUMNS
    WHERE TABSCHEMA = SOURCE_SCHEMA
    AND TABNAME = SOURCE_TABLE
    AND COLNO = 0!
CREATE FUNCTION X_HISTORY_EXPNAME(RESOLUTION VARCHAR(11))
    RETURNS VARCHAR(30)
    SPECIFIC X_HISTORY_EXPNAME1
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    CASE WHEN RESOLUTION IN (
            'MICROSECOND',
            'SECOND',
            'MINUTE',
            'HOUR',
            'DAY',
            'WEEK',
            'WEEK_ISO',
            'MONTH',
            'YEAR'
        )
        THEN 'EXPIRY_' || RESOLUTION
        ELSE RAISE_ERROR('70001', 'Invalid RESOLUTION value ' || RESOLUTION)
    END!
CREATE FUNCTION X_HISTORY_EXPNAME(SOURCE_SCHEMA VARCHAR(128), SOURCE_TABLE VARCHAR(128))
    RETURNS VARCHAR(128)
    SPECIFIC X_HISTORY_EXPNAME2
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
RETURN
    SELECT COLNAME
    FROM SYSCAT.COLUMNS
    WHERE TABSCHEMA = SOURCE_SCHEMA
    AND TABNAME = SOURCE_TABLE
    AND COLNO = 1!
CREATE FUNCTION X_HISTORY_EFFDEFAULT(RESOLUTION VARCHAR(11))
    RETURNS VARCHAR(20)
    SPECIFIC X_HISTORY_EFFDEFAULT1
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    CASE
        WHEN RESOLUTION IN ('MICROSECOND', 'SECOND', 'MINUTE', 'HOUR') THEN 'CURRENT TIMESTAMP'
        WHEN RESOLUTION IN ('DAY', 'WEEK', 'WEEK_ISO', 'MONTH', 'YEAR') THEN 'CURRENT DATE'
        ELSE RAISE_ERROR('70001', 'Invalid RESOLUTION value ' || RESOLUTION)
    END!
CREATE FUNCTION X_HISTORY_EFFDEFAULT(SOURCE_SCHEMA VARCHAR(128), SOURCE_TABLE VARCHAR(128))
    RETURNS VARCHAR(254)
    SPECIFIC X_HISTORY_EFFDEFAULT2
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
RETURN
    SELECT DEFAULT
    FROM SYSCAT.COLUMNS
    WHERE TABSCHEMA = SOURCE_SCHEMA
    AND TABNAME = SOURCE_TABLE
    AND COLNO = 0!
CREATE FUNCTION X_HISTORY_EXPDEFAULT(RESOLUTION VARCHAR(11))
    RETURNS VARCHAR(40)
    SPECIFIC X_HISTORY_EXPDEFAULT1
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    CASE
        WHEN RESOLUTION IN ('MICROSECOND', 'SECOND', 'MINUTE', 'HOUR') THEN 'TIMESTAMP(''9999-12-31 23:59:59.999999'')'
        WHEN RESOLUTION IN ('DAY', 'WEEK', 'WEEK_ISO', 'MONTH', 'YEAR') THEN 'DATE(''9999-12-31'')'
        ELSE RAISE_ERROR('70001', 'Invalid RESOLUTION value ' || RESOLUTION)
    END!
CREATE FUNCTION X_HISTORY_EXPDEFAULT(SOURCE_SCHEMA VARCHAR(128), SOURCE_TABLE VARCHAR(128))
    RETURNS VARCHAR(254)
    SPECIFIC X_HISTORY_EXPDEFAULT2
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
RETURN
    SELECT DEFAULT
    FROM SYSCAT.COLUMNS
    WHERE TABSCHEMA = SOURCE_SCHEMA
    AND TABNAME = SOURCE_TABLE
    AND COLNO = 1!
CREATE FUNCTION X_HISTORY_PERIODSTART(RESOLUTION VARCHAR(11), EXPRESSION VARCHAR(100))
    RETURNS VARCHAR(100)
    SPECIFIC X_HISTORY_PERIODSTART
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    CASE RESOLUTION
        WHEN 'MICROSECOND' THEN                        EXPRESSION
        WHEN 'SECOND'      THEN 'SECONDSTART('      || EXPRESSION || ')'
        WHEN 'MINUTE'      THEN 'MINUTESTART('      || EXPRESSION || ')'
        WHEN 'HOUR'        THEN 'HOURSTART('        || EXPRESSION || ')'
        WHEN 'DAY'         THEN                        EXPRESSION
        WHEN 'WEEK'        THEN 'WEEKSTART('        || EXPRESSION || ')'
        WHEN 'WEEK_ISO'    THEN 'WEEKSTART_ISO('    || EXPRESSION || ')'
        WHEN 'MONTH'       THEN 'MONTHSTART('       || EXPRESSION || ')'
        WHEN 'YEAR'        THEN 'YEARSTART('        || EXPRESSION || ')'
        ELSE RAISE_ERROR('70001', 'Invalid RESOLUTION value ' || RESOLUTION)
    END!
CREATE FUNCTION X_HISTORY_PERIODEND(RESOLUTION VARCHAR(11), EXPRESSION VARCHAR(100))
    RETURNS VARCHAR(100)
    SPECIFIC X_HISTORY_PERIODEND
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    CASE RESOLUTION
        WHEN 'MICROSECOND' THEN                      EXPRESSION
        WHEN 'SECOND'      THEN 'SECONDEND('      || EXPRESSION || ')'
        WHEN 'MINUTE'      THEN 'MINUTEEND('      || EXPRESSION || ')'
        WHEN 'HOUR'        THEN 'HOUREND('        || EXPRESSION || ')'
        WHEN 'DAY'         THEN                      EXPRESSION
        WHEN 'WEEK'        THEN 'WEEKEND('        || EXPRESSION || ')'
        WHEN 'WEEK_ISO'    THEN 'WEEKEND_ISO('    || EXPRESSION || ')'
        WHEN 'MONTH'       THEN 'MONTHEND('       || EXPRESSION || ')'
        WHEN 'YEAR'        THEN 'YEAREND('        || EXPRESSION || ')'
        ELSE RAISE_ERROR('70001', 'Invalid RESOLUTION value ' || RESOLUTION)
    END!
CREATE FUNCTION X_HISTORY_PERIODLEN(RESOLUTION VARCHAR(11))
    RETURNS VARCHAR(13)
    SPECIFIC X_HISTORY_PERIODLEN
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    CASE RESOLUTION
        WHEN 'MICROSECOND' THEN '1 MICROSECOND'
        WHEN 'SECOND'      THEN '1 SECOND'
        WHEN 'MINUTE'      THEN '1 MINUTE'
        WHEN 'HOUR'        THEN '1 HOUR'
        WHEN 'DAY'         THEN '1 DAY'
        WHEN 'WEEK'        THEN '7 DAYS'
        WHEN 'WEEK_ISO'    THEN '7 DAYS'
        WHEN 'MONTH'       THEN '1 MONTH'
        WHEN 'YEAR'        THEN '1 YEAR'
        ELSE RAISE_ERROR('70001', 'Invalid RESOLUTION value ' || RESOLUTION)
    END!
CREATE FUNCTION X_HISTORY_PERIODSTEP(RESOLUTION VARCHAR(11))
    RETURNS VARCHAR(13)
    SPECIFIC X_HISTORY_PERIODSTEP1
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    CASE
        WHEN RESOLUTION IN ('MICROSECOND', 'SECOND', 'MINUTE', 'HOUR') THEN '1 MICROSECOND'
        WHEN RESOLUTION IN ('DAY', 'WEEK', 'WEEK_ISO', 'MONTH', 'YEAR') THEN '1 DAY'
        ELSE RAISE_ERROR('70001', 'Invalid RESOLUTION value ' || RESOLUTION)
    END!
CREATE FUNCTION X_HISTORY_PERIODSTEP(SOURCE_SCHEMA VARCHAR(128), SOURCE_TABLE VARCHAR(128))
    RETURNS VARCHAR(13)
    SPECIFIC X_HISTORY_PERIODSTEP2
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
RETURN
    CASE (
            SELECT TYPENAME
            FROM SYSCAT.COLUMNS
            WHERE TABSCHEMA = SOURCE_SCHEMA
            AND TABNAME = SOURCE_TABLE
            AND COLNO = 0
        )
        WHEN 'TIMESTAMP' THEN '1 MICROSECOND'
        WHEN 'DATE' THEN '1 DAY'
        ELSE RAISE_ERROR('70001', 'Unexpected datatype found in effective column')
    END!
CREATE FUNCTION X_HISTORY_EFFNEXT(RESOLUTION VARCHAR(11), OFFSET VARCHAR(100))
    RETURNS VARCHAR(100)
    SPECIFIC X_HISTORY_EFFNEXT
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    X_HISTORY_PERIODSTART(RESOLUTION, X_HISTORY_EFFDEFAULT(RESOLUTION) || OFFSET)!
CREATE FUNCTION X_HISTORY_EXPPRIOR(RESOLUTION VARCHAR(11), OFFSET VARCHAR(100))
    RETURNS VARCHAR(100)
    SPECIFIC X_HISTORY_EXPPRIOR
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    X_HISTORY_PERIODEND(RESOLUTION, X_HISTORY_EFFDEFAULT(RESOLUTION) || ' - ' || X_HISTORY_PERIODLEN(RESOLUTION) || ' ' || OFFSET)!
CREATE FUNCTION X_HISTORY_INSERT(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    RESOLUTION VARCHAR(11),
    OFFSET VARCHAR(100)
)
    RETURNS CLOB(64K)
    SPECIFIC X_HISTORY_INSERT
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
BEGIN ATOMIC
    DECLARE INSERT_STMT CLOB(64K) DEFAULT '';
    DECLARE VALUES_STMT CLOB(64K) DEFAULT '';
    SET INSERT_STMT = 'INSERT INTO ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE) || '(';
    SET VALUES_STMT = ' VALUES (';
    SET INSERT_STMT = INSERT_STMT || QUOTE_IDENTIFIER(X_HISTORY_EFFNAME(DEST_SCHEMA, DEST_TABLE));
    SET VALUES_STMT = VALUES_STMT || X_HISTORY_EFFNEXT(RESOLUTION, OFFSET);
    FOR C AS
        SELECT COLNAME
        FROM SYSCAT.COLUMNS
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        ORDER BY COLNO
    DO
        SET INSERT_STMT = INSERT_STMT || ',' || QUOTE_IDENTIFIER(C.COLNAME);
        SET VALUES_STMT = VALUES_STMT || ',NEW.' || QUOTE_IDENTIFIER(C.COLNAME);
    END FOR;
    SET INSERT_STMT = INSERT_STMT || ')';
    SET VALUES_STMT = VALUES_STMT || ')';
    RETURN INSERT_STMT || VALUES_STMT;
END!
CREATE FUNCTION X_HISTORY_EXPIRE(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    RESOLUTION VARCHAR(11),
    OFFSET VARCHAR(100)
)
    RETURNS CLOB(64K)
    SPECIFIC X_HISTORY_EXPIRE
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
BEGIN ATOMIC
    DECLARE UPDATE_STMT CLOB(64K) DEFAULT '';
    SET UPDATE_STMT = 'UPDATE ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE)
        || ' SET '   || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(DEST_SCHEMA, DEST_TABLE)) || ' = ' || X_HISTORY_EXPPRIOR(RESOLUTION, OFFSET)
        || ' WHERE ' || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(DEST_SCHEMA, DEST_TABLE)) || ' = ' || X_HISTORY_EXPDEFAULT(RESOLUTION);
    FOR C AS
        SELECT COLNAME
        FROM SYSCAT.COLUMNS
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        AND COALESCE(KEYSEQ, 0) > 0
        ORDER BY COLNO
    DO
        SET UPDATE_STMT = UPDATE_STMT || ' AND ' || QUOTE_IDENTIFIER(C.COLNAME) || ' = OLD.' || QUOTE_IDENTIFIER(C.COLNAME);
    END FOR;
    RETURN UPDATE_STMT;
END!
CREATE FUNCTION X_HISTORY_UPDATE(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    RESOLUTION VARCHAR(11)
)
    RETURNS CLOB(64K)
    SPECIFIC X_HISTORY_UPDATE
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
BEGIN ATOMIC
    DECLARE UPDATE_STMT CLOB(64K) DEFAULT '';
    DECLARE SET_STMT CLOB(64K) DEFAULT '';
    DECLARE WHERE_STMT CLOB(64K) DEFAULT '';
    SET UPDATE_STMT = 'UPDATE ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE) || ' ';
    SET WHERE_STMT = ' WHERE ' || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(DEST_SCHEMA, DEST_TABLE)) || ' = ' || X_HISTORY_EXPDEFAULT(RESOLUTION);
    FOR C AS
        SELECT COALESCE(KEYSEQ, 0) AS KEYSEQ, COLNAME
        FROM SYSCAT.COLUMNS
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        ORDER BY COLNO
    DO
        IF C.KEYSEQ = 0 THEN
            SET SET_STMT = SET_STMT || ', ' || QUOTE_IDENTIFIER(C.COLNAME) || ' = NEW.' || QUOTE_IDENTIFIER(C.COLNAME);
        ELSE
            SET WHERE_STMT = WHERE_STMT || ' AND ' || QUOTE_IDENTIFIER(C.COLNAME) || ' = OLD.' || QUOTE_IDENTIFIER(C.COLNAME);
        END IF;
    END FOR;
    SET SET_STMT = 'SET' || SUBSTR(SET_STMT, 2);
    RETURN UPDATE_STMT || SET_STMT || WHERE_STMT;
END!
CREATE FUNCTION X_HISTORY_DELETE(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    RESOLUTION VARCHAR(11)
)
    RETURNS CLOB(64K)
    SPECIFIC X_HISTORY_DELETE
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
BEGIN ATOMIC
    DECLARE DELETE_STMT CLOB(64K) DEFAULT '';
    DECLARE WHERE_STMT CLOB(64K) DEFAULT '';
    SET DELETE_STMT = 'DELETE FROM ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE);
    SET WHERE_STMT = ' WHERE ' || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(DEST_SCHEMA, DEST_TABLE)) || ' = ' || X_HISTORY_EXPDEFAULT(RESOLUTION);
    FOR C AS
        SELECT COLNAME
        FROM SYSCAT.COLUMNS
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        AND COALESCE(KEYSEQ, 0) > 0
        ORDER BY COLNO
    DO
        SET WHERE_STMT = WHERE_STMT || ' AND ' || QUOTE_IDENTIFIER(C.COLNAME) || ' = OLD.' || QUOTE_IDENTIFIER(C.COLNAME);
    END FOR;
    RETURN DELETE_STMT || WHERE_STMT;
END!
CREATE FUNCTION X_HISTORY_CHECK(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    RESOLUTION VARCHAR(11)
)
    RETURNS CLOB(64K)
    SPECIFIC X_HISTORY_CHECK
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
BEGIN ATOMIC
    DECLARE SELECT_STMT CLOB(64K) DEFAULT '';
    DECLARE WHERE_STMT CLOB(64K) DEFAULT '';
    SET SELECT_STMT =
        'SELECT ' || X_HISTORY_PERIODEND(RESOLUTION, X_HISTORY_EFFNAME(RESOLUTION))
        || ' FROM ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE);
    SET WHERE_STMT =
        ' WHERE ' || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(DEST_SCHEMA, DEST_TABLE)) || ' = ' || X_HISTORY_EXPDEFAULT(RESOLUTION);
    FOR C AS
        SELECT COLNAME
        FROM SYSCAT.COLUMNS
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        AND COALESCE(KEYSEQ, 0) > 0
        ORDER BY COLNO
    DO
        SET WHERE_STMT = WHERE_STMT || ' AND ' || QUOTE_IDENTIFIER(C.COLNAME) || ' = OLD.' || QUOTE_IDENTIFIER(C.COLNAME);
    END FOR;
    RETURN SELECT_STMT || WHERE_STMT;
END!
CREATE FUNCTION X_HISTORY_CHANGES(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128)
)
    RETURNS CLOB(64K)
    SPECIFIC X_HISTORY_CHANGES
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
BEGIN ATOMIC
    DECLARE SELECT_STMT CLOB(64K) DEFAULT '';
    DECLARE FROM_STMT CLOB(64K) DEFAULT '';
    DECLARE INSERT_TEST CLOB(64K) DEFAULT '';
    DECLARE UPDATE_TEST CLOB(64K) DEFAULT '';
    DECLARE DELETE_TEST CLOB(64K) DEFAULT '';
    SET FROM_STMT =
        ' FROM ' || QUOTE_IDENTIFIER('OLD_' || SOURCE_TABLE) || ' AS OLD'
        || ' FULL OUTER JOIN ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE) || ' AS NEW'
        || ' ON NEW.' || X_HISTORY_EFFNAME(SOURCE_SCHEMA, SOURCE_TABLE) || ' - ' || X_HISTORY_PERIODSTEP(SOURCE_SCHEMA, SOURCE_TABLE)
        || ' BETWEEN OLD.' || X_HISTORY_EFFNAME(SOURCE_SCHEMA, SOURCE_TABLE)
        || ' AND OLD.' || X_HISTORY_EXPNAME(SOURCE_SCHEMA, SOURCE_TABLE);
    FOR C AS
        SELECT COALESCE(KEYSEQ, 0) AS KEYSEQ, COLNAME
        FROM SYSCAT.COLUMNS
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        AND COLNO >= 2
        ORDER BY COLNO
    DO
        SET SELECT_STMT = SELECT_STMT
            || ', OLD.' || QUOTE_IDENTIFIER(C.COLNAME) || ' AS ' || QUOTE_IDENTIFIER('OLD_' || C.COLNAME)
            || ', NEW.' || QUOTE_IDENTIFIER(C.COLNAME) || ' AS ' || QUOTE_IDENTIFIER('NEW_' || C.COLNAME);
        IF C.KEYSEQ > 0 THEN
            SET FROM_STMT = FROM_STMT
                || ' AND OLD.' || QUOTE_IDENTIFIER(C.COLNAME) || ' = NEW.' || QUOTE_IDENTIFIER(C.COLNAME);
            SET INSERT_TEST = INSERT_TEST
                || 'AND OLD.' || QUOTE_IDENTIFIER(C.COLNAME) || ' IS NULL '
                || 'AND NEW.' || QUOTE_IDENTIFIER(C.COLNAME) || ' IS NOT NULL ';
            SET UPDATE_TEST = UPDATE_TEST
                || 'AND OLD.' || QUOTE_IDENTIFIER(C.COLNAME) || ' IS NOT NULL '
                || 'AND NEW.' || QUOTE_IDENTIFIER(C.COLNAME) || ' IS NOT NULL ';
            SET DELETE_TEST = DELETE_TEST
                || 'AND OLD.' || QUOTE_IDENTIFIER(C.COLNAME) || ' IS NOT NULL '
                || 'AND NEW.' || QUOTE_IDENTIFIER(C.COLNAME) || ' IS NULL ';
        END IF;
    END FOR;
    SET SELECT_STMT =
        'SELECT'
        || ' COALESCE(NEW.'
            || QUOTE_IDENTIFIER(X_HISTORY_EFFNAME(SOURCE_SCHEMA, SOURCE_TABLE)) || ', OLD.'
            || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(SOURCE_SCHEMA, SOURCE_TABLE)) || ' + ' || X_HISTORY_PERIODSTEP(SOURCE_SCHEMA, SOURCE_TABLE) || ') AS CHANGED'
        || ', CHAR(CASE '
            || 'WHEN' || SUBSTR(INSERT_TEST, 4) || 'THEN ''INSERT'' '
            || 'WHEN' || SUBSTR(UPDATE_TEST, 4) || 'THEN ''UPDATE'' '
            || 'WHEN' || SUBSTR(DELETE_TEST, 4) || 'THEN ''DELETE'' '
            || 'ELSE ''ERROR'' END) AS CHANGE'
        || SELECT_STMT;
    RETURN
        'WITH ' || QUOTE_IDENTIFIER('OLD_' || SOURCE_TABLE) || ' AS ('
        || '    SELECT *'
        || '    FROM ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE)
        || '    WHERE ' || X_HISTORY_EXPNAME(SOURCE_SCHEMA, SOURCE_TABLE) || ' < ' || X_HISTORY_EXPDEFAULT(SOURCE_SCHEMA, SOURCE_TABLE)
        || ') '
        || SELECT_STMT
        || FROM_STMT;
END!
CREATE FUNCTION X_HISTORY_SNAPSHOTS(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    RESOLUTION VARCHAR(11)
)
    RETURNS CLOB(64K)
    SPECIFIC X_HISTORY_SNAPSHOTS
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
BEGIN ATOMIC
    DECLARE SELECT_STMT CLOB(64K) DEFAULT '';
    SET SELECT_STMT =
        'WITH RANGE(D) AS ('
        || '    SELECT MIN(' || QUOTE_IDENTIFIER(X_HISTORY_EFFNAME(SOURCE_SCHEMA, SOURCE_TABLE)) || ')'
        || '    FROM ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE)
        || '    UNION ALL'
        || '    SELECT D + ' || X_HISTORY_PERIODLEN(RESOLUTION)
        || '    FROM RANGE'
        || '    WHERE D <= ' || X_HISTORY_EFFDEFAULT(RESOLUTION)
        || ') '
        || 'SELECT ' || X_HISTORY_PERIODEND(RESOLUTION, 'R.D') || ' AS SNAPSHOT';
    FOR C AS
        SELECT COLNAME
        FROM SYSCAT.COLUMNS
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        AND COLNO >= 2
        ORDER BY COLNO
    DO
        SET SELECT_STMT = SELECT_STMT
            || ', H.' || QUOTE_IDENTIFIER(C.COLNAME);
    END FOR;
    RETURN SELECT_STMT
        || ' FROM RANGE R INNER JOIN ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE) || ' H'
        || ' ON R.D BETWEEN H.' || QUOTE_IDENTIFIER(X_HISTORY_EFFNAME(SOURCE_SCHEMA, SOURCE_TABLE))
        || ' AND H.' || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(SOURCE_SCHEMA, SOURCE_TABLE));
END!
CREATE FUNCTION X_HISTORY_UPDATE_FIELDS(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    KEY_FIELDS CHAR(1)
)
    RETURNS CLOB(64K)
    SPECIFIC X_HISTORY_UPDATE_FIELDS
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
BEGIN ATOMIC
    DECLARE RESULT CLOB(64K) DEFAULT '';
    IF NOT KEY_FIELDS IN ('N', 'Y') THEN
        CALL SIGNAL_STATE(HISTORY_KEY_FIELDS_STATE, 'KEY_FIELDS must be N or Y');
    END IF;
    FOR C AS
        SELECT COLNAME
        FROM SYSCAT.COLUMNS
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        AND (
            (KEY_FIELDS = 'Y' AND COALESCE(KEYSEQ, 0) > 0) OR
            (KEY_FIELDS = 'N' AND COALESCE(KEYSEQ, 0) = 0)
        )
        ORDER BY COLNO
    DO
        SET RESULT = RESULT || ', ' || QUOTE_IDENTIFIER(C.COLNAME);
    END FOR;
    RETURN SUBSTR(RESULT, 2);
END!
CREATE FUNCTION X_HISTORY_UPDATE_WHEN(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    KEY_FIELDS CHAR(1)
)
    RETURNS CLOB(64K)
    SPECIFIC X_HISTORY_UPDATE_WHEN
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
BEGIN ATOMIC
    DECLARE RESULT CLOB(64K) DEFAULT '';
    IF NOT KEY_FIELDS IN ('N', 'Y') THEN
        CALL SIGNAL_STATE(HISTORY_KEY_FIELDS_STATE, 'KEY_FIELDS must be N or Y');
    END IF;
    FOR C AS
        SELECT COLNAME, NULLS
        FROM SYSCAT.COLUMNS
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        AND (
            (KEY_FIELDS = 'Y' AND COALESCE(KEYSEQ, 0) > 0) OR
            (KEY_FIELDS = 'N' AND COALESCE(KEYSEQ, 0) = 0)
        )
        ORDER BY COLNO
    DO
        SET RESULT = RESULT || ' OR OLD.' || QUOTE_IDENTIFIER(C.COLNAME) || ' <> NEW.' || QUOTE_IDENTIFIER(C.COLNAME);
        IF C.NULLS = 'Y' THEN
            SET RESULT = RESULT || ' OR (OLD.' || QUOTE_IDENTIFIER(C.COLNAME) || ' IS NULL AND NEW.' || QUOTE_IDENTIFIER(C.COLNAME) || ' IS NOT NULL)';
            SET RESULT = RESULT || ' OR (NEW.' || QUOTE_IDENTIFIER(C.COLNAME) || ' IS NULL AND OLD.' || QUOTE_IDENTIFIER(C.COLNAME) || ' IS NOT NULL)';
        END IF;
    END FOR;
    RETURN SUBSTR(RESULT, 5);
END!
GRANT EXECUTE ON SPECIFIC PROCEDURE CREATE_HISTORY_TRIGGERS4 TO ROLE UTILS_HISTORY_USER!
GRANT EXECUTE ON SPECIFIC PROCEDURE CREATE_HISTORY_TRIGGERS4 TO ROLE UTILS_HISTORY_ADMIN WITH GRANT OPTION!
CREATE ROLE UTILS_MERGE_USER!
CREATE ROLE UTILS_MERGE_ADMIN!
GRANT ROLE UTILS_MERGE_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_MERGE_USER TO ROLE UTILS_MERGE_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_MERGE_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
CREATE VARIABLE MERGE_NO_KEY_STATE CHAR(5) CONSTANT '90010'!
CREATE VARIABLE MERGE_PARTIAL_KEY_STATE CHAR(5) CONSTANT '90011'!
CREATE VARIABLE MERGE_SAME_TABLE_STATE CHAR(5) CONSTANT '90012'!
GRANT READ ON VARIABLE MERGE_NO_KEY_STATE TO ROLE UTILS_MERGE_USER!
GRANT READ ON VARIABLE MERGE_NO_KEY_STATE TO ROLE UTILS_MERGE_ADMIN WITH GRANT OPTION!
GRANT READ ON VARIABLE MERGE_PARTIAL_KEY_STATE TO ROLE UTILS_MERGE_USER!
GRANT READ ON VARIABLE MERGE_PARTIAL_KEY_STATE TO ROLE UTILS_MERGE_ADMIN WITH GRANT OPTION!
GRANT READ ON VARIABLE MERGE_SAME_TABLE_STATE TO ROLE UTILS_MERGE_USER!
GRANT READ ON VARIABLE MERGE_SAME_TABLE_STATE TO ROLE UTILS_MERGE_ADMIN WITH GRANT OPTION!
COMMENT ON VARIABLE MERGE_NO_KEY_STATE
    IS 'The SQLSTATE raised when an attempt is made to AUTO_MERGE to a target without a unique constraint'!
COMMENT ON VARIABLE MERGE_PARTIAL_KEY_STATE
    IS 'The SQLSTATE raised when AUTO_MERGE is run on a key which does not completely exist in the source and target tables'!
COMMENT ON VARIABLE MERGE_SAME_TABLE_STATE
    IS 'The SQLSTATE raised when AUTO_MERGE is run with the same table as source and target'!
CREATE FUNCTION X_BUILD_INSERT(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128)
)
    RETURNS CLOB(64K)
    SPECIFIC X_BUILD_INSERT
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
BEGIN ATOMIC
    DECLARE COLS CLOB(64K) DEFAULT '';

    FOR D AS
        SELECT
            T.COLNAME AS NAME
        FROM
            SYSCAT.COLUMNS S
            INNER JOIN SYSCAT.COLUMNS T
                ON S.COLNAME = T.COLNAME
        WHERE
            S.TABSCHEMA = SOURCE_SCHEMA
            AND S.TABNAME = SOURCE_TABLE
            AND T.TABSCHEMA = DEST_SCHEMA
            AND T.TABNAME = DEST_TABLE
    DO
        IF COLS <> '' THEN
            SET COLS = COLS || ',';
        END IF;
        SET COLS = COLS || QUOTE_IDENTIFIER(NAME);
    END FOR;

    RETURN
        'INSERT INTO ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE) || ' '
        || '(' || COLS || ') '
        || 'SELECT ' || COLS || ' '
        || 'FROM ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE);
END!
CREATE FUNCTION X_BUILD_MERGE(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    DEST_KEY VARCHAR(128)
)
    RETURNS CLOB(64K)
    SPECIFIC X_BUILD_MERGE
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
BEGIN ATOMIC
    DECLARE JOIN_CLAUSE CLOB(64K) DEFAULT '';
    DECLARE INSERT_COLS CLOB(64K) DEFAULT '';
    DECLARE INSERT_VALS CLOB(64K) DEFAULT '';
    DECLARE UPDATE_COLS CLOB(64K) DEFAULT '';
    DECLARE UPDATE_VALS CLOB(64K) DEFAULT '';

    FOR D AS
        SELECT
            T.COLNAME AS NAME,
            CASE WHEN K.COLNAME IS NULL
                THEN 'N'
                ELSE 'Y'
            END AS KEY_COL
        FROM
            SYSCAT.COLUMNS S
            INNER JOIN SYSCAT.COLUMNS T
                ON S.COLNAME = T.COLNAME
            INNER JOIN SYSCAT.TABCONST C
                ON T.TABSCHEMA = C.TABSCHEMA
                AND T.TABNAME = C.TABNAME
            LEFT JOIN SYSCAT.KEYCOLUSE K
                ON C.TABSCHEMA = K.TABSCHEMA
                AND C.TABNAME = K.TABNAME
                AND C.CONSTNAME = K.CONSTNAME
                AND T.COLNAME = K.COLNAME
        WHERE
            S.TABSCHEMA = SOURCE_SCHEMA
            AND S.TABNAME = SOURCE_TABLE
            AND T.TABSCHEMA = DEST_SCHEMA
            AND T.TABNAME = DEST_TABLE
            AND C.CONSTNAME = DEST_KEY
            AND C.TYPE IN ('P', 'U')
    DO
        IF D.KEY_COL = 'Y' THEN
            IF JOIN_CLAUSE <> '' THEN
                SET JOIN_CLAUSE = JOIN_CLAUSE || ' AND ';
            END IF;
            SET JOIN_CLAUSE = JOIN_CLAUSE ||
                'S.' || QUOTE_IDENTIFIER(NAME) || ' = ' ||
                'T.' || QUOTE_IDENTIFIER(NAME);
        ELSE
            IF UPDATE_COLS <> '' THEN
                SET UPDATE_COLS = UPDATE_COLS || ',';
                SET UPDATE_VALS = UPDATE_VALS || ',';
            END IF;
            SET UPDATE_COLS = UPDATE_COLS || QUOTE_IDENTIFIER(NAME);
            SET UPDATE_VALS = UPDATE_VALS || 'S.' || QUOTE_IDENTIFIER(NAME);
        END IF;
        IF INSERT_COLS <> '' THEN
            SET INSERT_COLS = INSERT_COLS || ',';
            SET INSERT_VALS = INSERT_VALS || ',';
        END IF;
        SET INSERT_COLS = INSERT_COLS || QUOTE_IDENTIFIER(NAME);
        SET INSERT_VALS = INSERT_VALS || 'S.' || QUOTE_IDENTIFIER(NAME);
    END FOR;

    RETURN
        'MERGE INTO ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE) || ' AS T '
        || 'USING ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE) || ' AS S '
        || 'ON ' || JOIN_CLAUSE || ' '
        || 'WHEN MATCHED THEN UPDATE SET (' || UPDATE_COLS || ') = (' || UPDATE_VALS || ') '
        || 'WHEN NOT MATCHED THEN INSERT (' || INSERT_COLS || ') VALUES (' || INSERT_VALS || ')';
END!
CREATE FUNCTION X_BUILD_DELETE(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    DEST_KEY VARCHAR(128)
)
    RETURNS CLOB(64K)
    SPECIFIC X_BUILD_DELETE
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    READS SQL DATA
BEGIN ATOMIC
    DECLARE KEY_COLS CLOB(64K) DEFAULT '';

    FOR D AS
        SELECT
            T.COLNAME AS NAME,
            CASE WHEN K.COLNAME IS NULL
                THEN 'N'
                ELSE 'Y'
            END AS KEY_COL
        FROM
            SYSCAT.COLUMNS S
            INNER JOIN SYSCAT.COLUMNS T
                ON S.COLNAME = T.COLNAME
            INNER JOIN SYSCAT.TABCONST C
                ON T.TABSCHEMA = C.TABSCHEMA
                AND T.TABNAME = C.TABNAME
            INNER JOIN SYSCAT.KEYCOLUSE K
                ON C.TABSCHEMA = K.TABSCHEMA
                AND C.TABNAME = K.TABNAME
                AND C.CONSTNAME = K.CONSTNAME
                AND T.COLNAME = K.COLNAME
        WHERE
            S.TABSCHEMA = SOURCE_SCHEMA
            AND S.TABNAME = SOURCE_TABLE
            AND T.TABSCHEMA = DEST_SCHEMA
            AND T.TABNAME = DEST_TABLE
            AND C.CONSTNAME = DEST_KEY
            AND C.TYPE IN ('P', 'U')
    DO
        IF KEY_COLS <> '' THEN
            SET KEY_COLS = KEY_COLS || ',';
        END IF;
        SET KEY_COLS = KEY_COLS || QUOTE_IDENTIFIER(NAME);
    END FOR;

    RETURN
        'DELETE FROM ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE) || ' '
        || 'WHERE (' || KEY_COLS || ') IN ('
        || 'SELECT ' || KEY_COLS || ' '
        || 'FROM ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE) || ' '
        || 'EXCEPT '
        || 'SELECT ' || KEY_COLS || ' '
        || 'FROM ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE)
        || ')';
END!
CREATE PROCEDURE X_INSERT_CHECKS(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128)
)
    SPECIFIC X_INSERT_CHECKS
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    CALL ASSERT_TABLE_EXISTS(SOURCE_SCHEMA, SOURCE_TABLE);
    CALL ASSERT_TABLE_EXISTS(DEST_SCHEMA, DEST_TABLE);

    -- Check source and target are distinct
    IF SOURCE_SCHEMA = DEST_SCHEMA THEN
        IF SOURCE_TABLE = DEST_TABLE THEN
            CALL SIGNAL_STATE(MERGE_SAME_TABLE_STATE,
                'Source and destination tables cannot be the same');
        END IF;
    END IF;
END!
CREATE PROCEDURE X_MERGE_CHECKS(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    DEST_KEY VARCHAR(128)
)
    SPECIFIC X_MERGE_CHECKS
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    CALL X_INSERT_CHECKS(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE);

    -- Check all columns of the destination key are present in the source table
    IF (
        SELECT COUNT(*)
        FROM SYSCAT.KEYCOLUSE
        WHERE
            TABSCHEMA = DEST_SCHEMA
            AND TABNAME = DEST_TABLE
            AND CONSTNAME = DEST_KEY
        ) <> (
        SELECT COUNT(*)
        FROM
            SYSCAT.KEYCOLUSE K
            INNER JOIN SYSCAT.COLUMNS C
                ON K.COLNAME = C.COLNAME
        WHERE
            K.TABSCHEMA = DEST_SCHEMA
            AND K.TABNAME = DEST_TABLE
            AND K.CONSTNAME = DEST_KEY
            AND C.TABSCHEMA = SOURCE_SCHEMA
            AND C.TABNAME = SOURCE_TABLE
        ) THEN
        CALL SIGNAL_STATE(MERGE_PARTIAL_KEY_STATE,
            'All fields of constraint ' || DEST_KEY ||
            ' must exist in the source and the target tables');
    END IF;

END!
CREATE PROCEDURE AUTO_INSERT(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128)
)
    SPECIFIC AUTO_INSERT1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE DML CLOB(64K) DEFAULT '';

    CALL X_INSERT_CHECKS(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE);
    SET DML = X_BUILD_INSERT(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE);
    EXECUTE IMMEDIATE DML;
END!
CREATE PROCEDURE AUTO_INSERT(
    SOURCE_TABLE VARCHAR(128),
    DEST_TABLE VARCHAR(128)
)
    SPECIFIC AUTO_INSERT2
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    CALL AUTO_INSERT(CURRENT SCHEMA, SOURCE_TABLE, CURRENT SCHEMA, DEST_TABLE);
END!
COMMENT ON SPECIFIC PROCEDURE AUTO_INSERT1
    IS 'Automatically inserts data from SOURCE_TABLE into DEST_TABLE'!
COMMENT ON SPECIFIC PROCEDURE AUTO_INSERT2
    IS 'Automatically inserts data from SOURCE_TABLE into DEST_TABLE'!
CREATE PROCEDURE AUTO_MERGE(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    DEST_KEY VARCHAR(128)
)
    SPECIFIC AUTO_MERGE1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE DML CLOB(64K) DEFAULT '';

    CALL X_MERGE_CHECKS(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, DEST_KEY);
    SET DML = X_BUILD_MERGE(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, DEST_KEY);
    EXECUTE IMMEDIATE DML;
END!
CREATE PROCEDURE AUTO_MERGE(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128)
)
    SPECIFIC AUTO_MERGE2
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    CALL AUTO_MERGE(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, (
        SELECT CONSTNAME
        FROM SYSCAT.TABCONST
        WHERE TABSCHEMA = DEST_SCHEMA
        AND TABNAME = DEST_TABLE
        AND TYPE = 'P'));
END!
CREATE PROCEDURE AUTO_MERGE(
    SOURCE_TABLE VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    DEST_KEY VARCHAR(128)
)
    SPECIFIC AUTO_MERGE3
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    CALL AUTO_MERGE(CURRENT SCHEMA, SOURCE_TABLE, CURRENT SCHEMA, DEST_TABLE, DEST_KEY);
END!
CREATE PROCEDURE AUTO_MERGE(
    SOURCE_TABLE VARCHAR(128),
    DEST_TABLE VARCHAR(128)
)
    SPECIFIC AUTO_MERGE4
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    CALL AUTO_MERGE(CURRENT SCHEMA, SOURCE_TABLE, CURRENT SCHEMA, DEST_TABLE, (
        SELECT CONSTNAME
        FROM SYSCAT.TABCONST
        WHERE TABSCHEMA = CURRENT SCHEMA
        AND TABNAME = DEST_TABLE
        AND TYPE = 'P'));
END!
COMMENT ON SPECIFIC PROCEDURE AUTO_MERGE1
    IS 'Automatically inserts/updates ("upserts") data from SOURCE_TABLE into DEST_TABLE based on DEST_KEY'!
COMMENT ON SPECIFIC PROCEDURE AUTO_MERGE2
    IS 'Automatically inserts/updates ("upserts") data from SOURCE_TABLE into DEST_TABLE based on DEST_KEY'!
COMMENT ON SPECIFIC PROCEDURE AUTO_MERGE3
    IS 'Automatically inserts/updates ("upserts") data from SOURCE_TABLE into DEST_TABLE based on DEST_KEY'!
COMMENT ON SPECIFIC PROCEDURE AUTO_MERGE4
    IS 'Automatically inserts/updates ("upserts") data from SOURCE_TABLE into DEST_TABLE based on DEST_KEY'!
CREATE PROCEDURE AUTO_DELETE(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    DEST_KEY VARCHAR(128)
)
    SPECIFIC AUTO_DELETE1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE DML CLOB(64K) DEFAULT '';

    CALL X_MERGE_CHECKS(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, DEST_KEY);
    SET DML = X_BUILD_DELETE(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, DEST_KEY);
    EXECUTE IMMEDIATE DML;
END!
CREATE PROCEDURE AUTO_DELETE(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128)
)
    SPECIFIC AUTO_DELETE2
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    CALL AUTO_DELETE(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, (
        SELECT CONSTNAME
        FROM SYSCAT.TABCONST
        WHERE TABSCHEMA = DEST_SCHEMA
        AND TABNAME = DEST_TABLE
        AND TYPE = 'P'));
END!
CREATE PROCEDURE AUTO_DELETE(
    SOURCE_TABLE VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    DEST_KEY VARCHAR(128)
)
    SPECIFIC AUTO_DELETE3
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    CALL AUTO_DELETE(CURRENT SCHEMA, SOURCE_TABLE, CURRENT SCHEMA, DEST_TABLE, DEST_KEY);
END!
CREATE PROCEDURE AUTO_DELETE(
    SOURCE_TABLE VARCHAR(128),
    DEST_TABLE VARCHAR(128)
)
    SPECIFIC AUTO_DELETE4
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    CALL AUTO_DELETE(CURRENT SCHEMA, SOURCE_TABLE, CURRENT SCHEMA, DEST_TABLE, (
        SELECT CONSTNAME
        FROM SYSCAT.TABCONST
        WHERE TABSCHEMA = CURRENT SCHEMA
        AND TABNAME = DEST_TABLE
        AND TYPE = 'P'));
END!
GRANT EXECUTE ON SPECIFIC PROCEDURE AUTO_DELETE4 TO ROLE UTILS_MERGE_USER!
GRANT EXECUTE ON SPECIFIC PROCEDURE AUTO_DELETE4 TO ROLE UTILS_MERGE_ADMIN WITH GRANT OPTION!
COMMENT ON SPECIFIC PROCEDURE AUTO_DELETE1
    IS 'Automatically removes data from DEST_TABLE that doesn''t exist in SOURCE_TABLE, based on DEST_KEY'!
COMMENT ON SPECIFIC PROCEDURE AUTO_DELETE2
    IS 'Automatically removes data from DEST_TABLE that doesn''t exist in SOURCE_TABLE, based on DEST_KEY'!
COMMENT ON SPECIFIC PROCEDURE AUTO_DELETE3
    IS 'Automatically removes data from DEST_TABLE that doesn''t exist in SOURCE_TABLE, based on DEST_KEY'!
COMMENT ON SPECIFIC PROCEDURE AUTO_DELETE4
    IS 'Automatically removes data from DEST_TABLE that doesn''t exist in SOURCE_TABLE, based on DEST_KEY'!
CREATE ROLE UTILS_PCRE_USER!
CREATE ROLE UTILS_PCRE_ADMIN!
GRANT ROLE UTILS_PCRE_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_PCRE_USER TO ROLE UTILS_PCRE_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_PCRE_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
GRANT EXECUTE ON SPECIFIC FUNCTION PCRE_SPLIT1 TO ROLE UTILS_PCRE_USER!
GRANT EXECUTE ON SPECIFIC FUNCTION PCRE_SPLIT1 TO ROLE UTILS_PCRE_ADMIN WITH GRANT OPTION!
CREATE ROLE UTILS_TOGGLE_TRIGGERS_USER!
CREATE ROLE UTILS_TOGGLE_TRIGGERS_ADMIN!
GRANT ROLE UTILS_TOGGLE_TRIGGERS_USER TO ROLE UTILS_USER!
GRANT ROLE UTILS_TOGGLE_TRIGGERS_USER TO ROLE UTILS_TOGGLE_TRIGGERS_ADMIN WITH ADMIN OPTION!
GRANT ROLE UTILS_TOGGLE_TRIGGERS_ADMIN TO ROLE UTILS_ADMIN WITH ADMIN OPTION!
CREATE VARIABLE TRIGGER_NOT_FOUND_STATE CHAR(5) CONSTANT '90007'!
CREATE VARIABLE TRIGGER_NOT_DISABLED_STATE CHAR(5) CONSTANT '90008'!
CREATE VARIABLE TRIGGER_NOT_ENABLED_STATE CHAR(5) CONSTANT '90009'!
GRANT READ ON VARIABLE TRIGGER_NOT_FOUND_STATE TO ROLE UTILS_TOGGLE_TRIGGERS_USER!
GRANT READ ON VARIABLE TRIGGER_NOT_DISABLED_STATE TO ROLE UTILS_TOGGLE_TRIGGERS_USER!
GRANT READ ON VARIABLE TRIGGER_NOT_ENABLED_STATE TO ROLE UTILS_TOGGLE_TRIGGERS_USER!
GRANT READ ON VARIABLE TRIGGER_NOT_FOUND_STATE TO ROLE UTILS_TOGGLE_TRIGGERS_ADMIN WITH GRANT OPTION!
GRANT READ ON VARIABLE TRIGGER_NOT_DISABLED_STATE TO ROLE UTILS_TOGGLE_TRIGGERS_ADMIN WITH GRANT OPTION!
GRANT READ ON VARIABLE TRIGGER_NOT_ENABLED_STATE TO ROLE UTILS_TOGGLE_TRIGGERS_ADMIN WITH GRANT OPTION!
COMMENT ON VARIABLE TRIGGER_NOT_FOUND_STATE
    IS 'The SQLSTATE raised when the trigger to be enabled/disabled cannot be found'!
COMMENT ON VARIABLE TRIGGER_NOT_DISABLED_STATE
    IS 'The SQLSTATE raised when an attempt to disable a trigger fails'!
COMMENT ON VARIABLE TRIGGER_NOT_ENABLED_STATE
    IS 'The SQLSTATE raised when an attempt to enable a trigger fails'!
GRANT EXECUTE ON SPECIFIC PROCEDURE ENABLE_TRIGGERS2 TO ROLE UTILS_TOGGLE_TRIGGERS_USER!
GRANT EXECUTE ON SPECIFIC PROCEDURE ENABLE_TRIGGERS2 TO ROLE UTILS_TOGGLE_TRIGGERS_ADMIN WITH GRANT OPTION!
COMMENT ON SPECIFIC FUNCTION QUOTE_STRING1
    IS 'Returns ASTRING surrounded by single quotes with all necessary escaping. Useful when constructing SQL for EXECUTE IMMEDIATE within a procedure'!
CREATE OR REPLACE PROCEDURE COPY_AUTH(
    SOURCE VARCHAR(128),
    SOURCE_TYPE VARCHAR(1),
    DEST VARCHAR(128),
    DEST_TYPE VARCHAR(1),
    INCLUDE_PERSONAL VARCHAR(1)
)
    SPECIFIC COPY_AUTH1
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    MODIFIES SQL DATA
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE NEWSTATE CHAR(5);
    DECLARE EXIT HANDLER FOR SQLSTATE '21000'
        BEGIN
            SET NEWSTATE = AUTH_AMBIGUOUS_STATE;
            SIGNAL SQLSTATE NEWSTATE
                SET MESSAGE_TEXT = 'Ambiguous type for authorization name';
        END;
    FOR D AS
        SELECT DDL
        FROM
            TABLE(X_COPY_LIST(SOURCE, SOURCE_TYPE, DEST, DEST_TYPE, INCLUDE_PERSONAL)) AS T
    DO
        EXECUTE IMMEDIATE D.DDL;
    END FOR;
END!
CREATE OR REPLACE PROCEDURE REMOVE_AUTH(
    AUTH_NAME VARCHAR(128),
    AUTH_TYPE VARCHAR(1),
    INCLUDE_PERSONAL VARCHAR(1)
)
    SPECIFIC REMOVE_AUTH1
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    MODIFIES SQL DATA
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE NEWSTATE CHAR(5);
    DECLARE EXIT HANDLER FOR SQLSTATE '21000'
        BEGIN
            SET NEWSTATE = AUTH_AMBIGUOUS_STATE;
            SIGNAL SQLSTATE NEWSTATE
                SET MESSAGE_TEXT = 'Ambiguous type for authorization name';
        END;
    -- If we remove CONTROL from a table, and the user holds CONTROL on a view
    -- defined over that table, the user implicitly loses CONTROL from the
    -- view. If we subsequently attempt to remove CONTROL the view then
    -- SQLSTATE 42504 will be raised but should be ignored. This SQLSTATE is
    -- also raised in the event that a REVOKE fails because CONTROL implies
    -- SELECT/INSERT/UPDATE/DELETE but the ORDER BY in X_REMOVE_LIST handles that
    -- particular case. Annoyingly, these two cases have the same SQLSTATE but
    -- different SQLCODEs - but we can only trap SQLSTATE with these handlers.
    DECLARE CONTINUE HANDLER FOR SQLSTATE '42504'
        BEGIN
        END;
    FOR D AS
        SELECT DDL
        FROM
            TABLE(X_REMOVE_LIST(AUTH_NAME, AUTH_TYPE, INCLUDE_PERSONAL)) AS T
        ORDER BY
            -- CONTROL must be removed before SELECT/INSERT/UPDATE/DELETE or
            -- DB2 complains that CONTROL implies the others
            CASE AUTH WHEN 'CONTROL' THEN 0 ELSE 1 END
    DO
        EXECUTE IMMEDIATE D.DDL;
    END FOR;
END!
CREATE OR REPLACE PROCEDURE RESTORE_AUTHS(ASCHEMA VARCHAR(128))
    SPECIFIC RESTORE_AUTHS1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    FOR D AS
        SELECT DISTINCT T.TABNAME
        FROM
            SYSCAT.TABLES T INNER JOIN SAVED_AUTH S
                ON T.TABSCHEMA = S.TABSCHEMA
                AND T.TABNAME = S.TABNAME
        WHERE T.TABSCHEMA = ASCHEMA
    DO
        CALL RESTORE_AUTH(ASCHEMA, D.TABNAME);
    END FOR;
    DELETE FROM SAVED_AUTH
        WHERE TABSCHEMA = ASCHEMA;
END!
CREATE OR REPLACE PROCEDURE RESTORE_AUTHS()
    SPECIFIC RESTORE_AUTHS2
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    CALL RESTORE_AUTH(CURRENT SCHEMA);
END!
CREATE OR REPLACE FUNCTION DATE_RANGE(START DATE, FINISH DATE, STEP DECIMAL(8, 0))
    RETURNS TABLE(D DATE)
    SPECIFIC DATE_RANGE1
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    -- The I counter in the recursive query exists simply to suppress the "may
    -- contain an infinite loop" warning. The value 37000 chosen as the limit
    -- allows the function to generate approximately a century's worth of dates
    -- which ought to be enough for most purposes. Adjust the limit if your
    -- users require larger ranges
    WITH RANGE(I, D) AS (
        (VALUES (1, START))
        UNION ALL
        (SELECT I + 1, D + STEP FROM RANGE WHERE I <= 37000 AND D + STEP <= FINISH)
    )
    SELECT D
    FROM RANGE
    WHERE START IS NOT NULL
    AND FINISH IS NOT NULL
    AND STEP IS NOT NULL!
CREATE OR REPLACE FUNCTION TS_FORMAT(AFORMAT VARCHAR(100), ATIMESTAMP TIMESTAMP)
    RETURNS VARCHAR(100)
    SPECIFIC TS_FORMAT1
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
BEGIN ATOMIC
    DECLARE I SMALLINT;
    DECLARE J SMALLINT;
    DECLARE RESULT VARCHAR(100);
    DECLARE FLAGS VARCHAR(5);
    DECLARE MINLEN INTEGER;
    IF AFORMAT IS NULL THEN
        RETURN NULL;
    END IF;
    IF ATIMESTAMP IS NULL THEN
        RETURN NULL;
    END IF;
    SET I = 1;
    SET RESULT = '';
    WHILE I <= LENGTH(AFORMAT) DO
        IF SUBSTR(AFORMAT, I, 1) = '%' AND I < LENGTH(AFORMAT) THEN
            SET I = I + 1;
            -- Extract the optional flags
            SET J = I;
            WHILE I < LENGTH(AFORMAT) AND LOCATE(SUBSTR(AFORMAT, J, 1), '_-0^#') > 0 DO
                SET J = J + 1;
            END WHILE;
            IF J > I THEN
                SET FLAGS = SUBSTR(AFORMAT, I, J - I);
                SET I = J;
            ELSE
                SET FLAGS = '';
            END IF;
            -- Extract the optional minimum length specification
            SET J = I;
            WHILE J < LENGTH(AFORMAT) AND LOCATE(SUBSTR(AFORMAT, J, 1), '0123456789') > 0 DO
                SET J = J + 1;
            END WHILE;
            IF J > I THEN
                SET MINLEN = INT(SUBSTR(AFORMAT, I, J - I));
                SET I = J;
            ELSE
                SET MINLEN = NULL;
            END IF;
            -- Act on the format specification
            SET RESULT = RESULT ||
                CASE SUBSTR(AFORMAT, I, 1)
                    WHEN '%' THEN '%'
                    WHEN 'a' THEN LEFT(DAYNAME(ATIMESTAMP), 3)
                    WHEN 'A' THEN DAYNAME(ATIMESTAMP)
                    WHEN 'b' THEN LEFT(MONTHNAME(ATIMESTAMP), 3)
                    WHEN 'B' THEN MONTHNAME(ATIMESTAMP)
                    WHEN 'c' THEN CHAR(DATE(ATIMESTAMP), LOCAL) || ' ' || CHAR(TIME(ATIMESTAMP), LOCAL)
                    WHEN 'C' THEN X_TS_FMT(YEAR(ATIMESTAMP) / 100,             FLAGS, COALESCE(MINLEN, 2), '0')
                    WHEN 'd' THEN X_TS_FMT(DAY(ATIMESTAMP),                    FLAGS, COALESCE(MINLEN, 2), '0')
                    WHEN 'D' THEN INSERT(CHAR(DATE(ATIMESTAMP), USA), 7, 2, '')
                    WHEN 'e' THEN X_TS_FMT(DAY(ATIMESTAMP),                    FLAGS, COALESCE(MINLEN, 2), ' ')
                    WHEN 'F' THEN CHAR(DATE(ATIMESTAMP), ISO)
                    WHEN 'g' THEN X_TS_FMT(MOD(YEAR_ISO(ATIMESTAMP), 100),     FLAGS, COALESCE(MINLEN, 2), '0')
                    WHEN 'G' THEN X_TS_FMT(YEAR_ISO(ATIMESTAMP),               FLAGS, COALESCE(MINLEN, 4), '0')
                    WHEN 'h' THEN X_TS_FMT(((MONTH(ATIMESTAMP) - 1) / 6) + 1,  FLAGS, COALESCE(MINLEN, 1), '0')
                    WHEN 'H' THEN X_TS_FMT(HOUR(ATIMESTAMP),                   FLAGS, COALESCE(MINLEN, 2), '0')
                    WHEN 'I' THEN X_TS_FMT(MOD(HOUR(ATIMESTAMP) + 11, 12) + 1, FLAGS, COALESCE(MINLEN, 2), '0')
                    WHEN 'j' THEN X_TS_FMT(DAYOFYEAR(ATIMESTAMP),              FLAGS, COALESCE(MINLEN, 3), '0')
                    WHEN 'k' THEN X_TS_FMT(HOUR(ATIMESTAMP),                   FLAGS, COALESCE(MINLEN, 2), ' ')
                    WHEN 'l' THEN X_TS_FMT(MOD(HOUR(ATIMESTAMP) + 11, 12) + 1, FLAGS, COALESCE(MINLEN, 2), ' ')
                    WHEN 'm' THEN X_TS_FMT(MONTH(ATIMESTAMP),                  FLAGS, COALESCE(MINLEN, 2), '0')
                    WHEN 'M' THEN X_TS_FMT(MINUTE(ATIMESTAMP),                 FLAGS, COALESCE(MINLEN, 2), '0')
                    WHEN 'n' THEN X'0A'
                    WHEN 'p' THEN CASE WHEN HOUR(ATIMESTAMP) < 12 THEN 'AM' ELSE 'PM' END
                    WHEN 'P' THEN CASE WHEN HOUR(ATIMESTAMP) < 12 THEN 'am' ELSE 'pm' END
                    WHEN 'q' THEN X_TS_FMT(QUARTER(ATIMESTAMP),                FLAGS, COALESCE(MINLEN, 1), '0')
                    WHEN 'S' THEN X_TS_FMT(SECOND(ATIMESTAMP),                 FLAGS, COALESCE(MINLEN, 2), '0')
                    WHEN 't' THEN X'09'
                    WHEN 'T' THEN CHAR(TIME(ATIMESTAMP), JIS)
                    WHEN 'u' THEN X_TS_FMT(DAYOFWEEK_ISO(ATIMESTAMP),          FLAGS, COALESCE(MINLEN, 1), '0')
                    WHEN 'U' THEN X_TS_FMT(WEEK(ATIMESTAMP),                   FLAGS, COALESCE(MINLEN, 2), '0')
                    WHEN 'V' THEN X_TS_FMT(WEEK_ISO(ATIMESTAMP),               FLAGS, COALESCE(MINLEN, 2), '0')
                    WHEN 'w' THEN X_TS_FMT(DAYOFWEEK(ATIMESTAMP),              FLAGS, COALESCE(MINLEN, 1), '0')
                    WHEN 'W' THEN X_TS_FMT(WEEK_ISO(ATIMESTAMP),               FLAGS, COALESCE(MINLEN, 2), '0')
                    WHEN 'x' THEN CHAR(DATE(ATIMESTAMP), LOCAL)
                    WHEN 'X' THEN CHAR(TIME(ATIMESTAMP), LOCAL)
                    WHEN 'y' THEN X_TS_FMT(MOD(YEAR(ATIMESTAMP), 100),         FLAGS, COALESCE(MINLEN, 2), '0')
                    WHEN 'Y' THEN X_TS_FMT(YEAR(ATIMESTAMP),                   FLAGS, COALESCE(MINLEN, 4), '0')
                    WHEN 'Z' THEN
                        CASE WHEN CURRENT TIMEZONE < 0 THEN '-' ELSE '+' END ||
                        TRANSLATE('AB:CD', DIGITS(CURRENT TIMEZONE), 'ABCDEF')
                    ELSE ''
                END;
        ELSE
            SET RESULT = RESULT || SUBSTR(AFORMAT, I, 1);
        END IF;
        SET I = I + 1;
    END WHILE;
    RETURN RESULT;
END!
CREATE OR REPLACE TRIGGER VACATIONS_INSERT
    NO CASCADE BEFORE INSERT ON VACATIONS
    REFERENCING NEW AS NEW
    FOR EACH ROW
WHEN (
    DAYOFWEEK(NEW.VACATION) IN (1, 7)
)
BEGIN ATOMIC
    CALL SIGNAL_STATE(VACATION_WEEKEND_STATE,
        'Cannot insert a weekend (Saturday / Sunday) date into VACATIONS');
END!
CREATE OR REPLACE TRIGGER VACATIONS_UPDATE
    NO CASCADE BEFORE UPDATE OF VACATION ON VACATIONS
    REFERENCING OLD AS OLD NEW AS NEW
    FOR EACH ROW
WHEN (
    DAYOFWEEK(NEW.VACATION) IN (1, 7)
)
BEGIN ATOMIC
    CALL SIGNAL_STATE(VACATION_WEEKEND_STATE,
        'Cannot change a date to a weekend (Saturday / Sunday) in VACATIONS');
END!
CREATE OR REPLACE FUNCTION WORKINGDAY(ADATE DATE, RELATIVE_TO DATE)
    RETURNS INTEGER
    SPECIFIC WORKINGDAY1
    LANGUAGE SQL
    DETERMINISTIC
    NO EXTERNAL ACTION
    CONTAINS SQL
RETURN
    X_WORKINGDAY_DAY(ADATE, RELATIVE_TO) - (
        ((X_WORKINGDAY_DAY(ADATE, RELATIVE_TO) + X_WORKINGDAY_SDOW(RELATIVE_TO)) / 7) +
        ((X_WORKINGDAY_DAY(ADATE, RELATIVE_TO) + X_WORKINGDAY_SDOW(RELATIVE_TO) - 1) / 7) -
        (X_WORKINGDAY_SDOW(RELATIVE_TO) / 7)
    )!
CREATE OR REPLACE PROCEDURE DROP_SCHEMA(ASCHEMA VARCHAR(128))
    SPECIFIC DROP_SCHEMA1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    FOR D AS
        SELECT DDL
        FROM TABLE(X_DROP_LIST(ASCHEMA))
        ORDER BY CREATE_TIME DESC
    DO
        EXECUTE IMMEDIATE D.DDL;
    END FOR;
END!
CREATE OR REPLACE PROCEDURE CREATE_HISTORY_TABLE(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    DEST_TBSPACE VARCHAR(18),
    RESOLUTION VARCHAR(11)
)
    SPECIFIC CREATE_HISTORY_TABLE1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE KEY_COLS CLOB(64K) DEFAULT '';
    DECLARE INC_COLS CLOB(64K) DEFAULT '';
    DECLARE DDL CLOB(64K) DEFAULT '';
    DECLARE SAVE_PATH VARCHAR(254);
    DECLARE SAVE_SCHEMA VARCHAR(128);
    DECLARE PK_CLUSTERED CHAR(1) DEFAULT 'N';
    DECLARE TAB_COMPRESSED CHAR(1) DEFAULT 'N';

    CALL ASSERT_TABLE_EXISTS(SOURCE_SCHEMA, SOURCE_TABLE);
    -- Check the source table has a primary key
    IF (SELECT COALESCE(KEYCOLUMNS, 0)
        FROM SYSCAT.TABLES
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE) = 0 THEN
            CALL SIGNAL_STATE(HISTORY_NO_PK_STATE, 'Source table must have a primary key');
    END IF;
    SET TAB_COMPRESSED = (
        SELECT
            CASE COMPRESSION
                WHEN 'R' THEN 'Y'
                WHEN 'B' THEN 'Y'
                ELSE 'N'
            END
        FROM SYSCAT.TABLES
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
    );
    SET PK_CLUSTERED = (
        SELECT
            CASE INDEXTYPE
                WHEN 'CLUS' THEN 'Y'
                ELSE 'N'
            END
        FROM SYSCAT.INDEXES
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        AND UNIQUERULE = 'P'
    );
    -- Drop any existing table with the same name as the destination table
    FOR D AS
        SELECT
            'DROP TABLE ' || QUOTE_IDENTIFIER(TABSCHEMA) || '.' || QUOTE_IDENTIFIER(TABNAME) AS DROP_CMD
        FROM
            SYSCAT.TABLES
        WHERE
            TABSCHEMA = DEST_SCHEMA
            AND TABNAME = DEST_TABLE
            AND TYPE = 'T'
    DO
        EXECUTE IMMEDIATE D.DROP_CMD;
    END FOR;
    -- Calculate comma-separated lists of key columns and include columns for
    -- later use in index and key statements
    FOR C AS
        SELECT
            CASE ICU.COLORDER
                WHEN 'I' THEN 'N'
                ELSE 'Y'
            END AS KEYCOL,
            ICU.COLNAME
        FROM
            SYSCAT.INDEXCOLUSE ICU
            INNER JOIN SYSCAT.INDEXES IND
                ON IND.INDSCHEMA = ICU.INDSCHEMA
                AND IND.INDNAME = ICU.INDNAME
        WHERE
            IND.TABSCHEMA = SOURCE_SCHEMA
            AND IND.TABNAME = SOURCE_TABLE
            AND IND.UNIQUERULE = 'P'
        ORDER BY
            ICU.COLSEQ
        FETCH FIRST 62 ROWS ONLY
    DO
        IF KEYCOL = 'Y' THEN
            SET KEY_COLS = KEY_COLS || QUOTE_IDENTIFIER(COLNAME) || ',';
        ELSE
            SET INC_COLS = INC_COLS || QUOTE_IDENTIFIER(COLNAME) || ',';
        END IF;
    END FOR;
    -- Create the history table based on the source table
    SET DDL =
        'CREATE TABLE ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE) || ' AS '
        || '('
        || '    SELECT'
        || '        ' || X_HISTORY_EFFDEFAULT(RESOLUTION) || ' AS ' || QUOTE_IDENTIFIER(X_HISTORY_EFFNAME(RESOLUTION)) || ','
        || '        ' || X_HISTORY_EXPDEFAULT(RESOLUTION) || ' AS ' || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(RESOLUTION)) || ','
        || '        T.*'
        || '    FROM '
        ||          QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE) || ' AS T'
        || ')'
        || 'WITH NO DATA IN ' || DEST_TBSPACE || ' '
        || 'COMPRESS ' || CASE TAB_COMPRESSED WHEN 'Y' THEN 'YES' ELSE 'NO' END;
    EXECUTE IMMEDIATE DDL;
    -- Create two unique indexes, both based on the source table's primary key,
    -- plus the EFFECTIVE and EXPIRY fields respectively. Use INCLUDE for
    -- additional small fields in the EFFECTIVE index. The columns included are
    -- the same as those included in the primary key of the source table.
    SET DDL =
        'CREATE UNIQUE INDEX ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE || '_PK') || ' '
        || 'ON ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE)
        || '(' || KEY_COLS || QUOTE_IDENTIFIER(X_HISTORY_EFFNAME(RESOLUTION))
        || ') INCLUDE (' || INC_COLS || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(RESOLUTION)) || ') '
        || CASE PK_CLUSTERED WHEN 'Y' THEN 'CLUSTER' ELSE '' END;
    EXECUTE IMMEDIATE DDL;
    SET DDL =
        'CREATE UNIQUE INDEX ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE || '_PK2') || ' '
        || 'ON ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE)
        || '(' || KEY_COLS || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(RESOLUTION))
        || ')';
    EXECUTE IMMEDIATE DDL;
    -- Create additional indexes that are useful for performance purposes
    SET DDL =
        'CREATE INDEX ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE || '_IX1') || ' '
        || 'ON ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE)
        || '(' || QUOTE_IDENTIFIER(X_HISTORY_EFFNAME(RESOLUTION)) || ', ' || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(RESOLUTION))
        || ')';
    EXECUTE IMMEDIATE DDL;
    -- Create a primary key with the same fields as the EFFECTIVE index defined
    -- above.
    SET DDL =
        'ALTER TABLE ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE) || ' '
        || 'ADD CONSTRAINT PK PRIMARY KEY (' || KEY_COLS || QUOTE_IDENTIFIER(X_HISTORY_EFFNAME(RESOLUTION)) || ') '
        || 'ADD CONSTRAINT EXPIRY_CK CHECK (' || QUOTE_IDENTIFIER(X_HISTORY_EFFNAME(RESOLUTION)) || ' <= ' || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(RESOLUTION)) || ') '
        || 'ALTER COLUMN ' || QUOTE_IDENTIFIER(X_HISTORY_EFFNAME(RESOLUTION)) || ' SET DEFAULT ' || X_HISTORY_EFFDEFAULT(RESOLUTION) || ' '
        || 'ALTER COLUMN ' || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(RESOLUTION)) || ' SET DEFAULT ' || X_HISTORY_EXPDEFAULT(RESOLUTION);
    EXECUTE IMMEDIATE DDL;
    -- Copy CHECK constraints from the source table to the history table. Note
    -- that we do not copy FOREIGN KEY constraints as there's no good method of
    -- matching a parent record in a historized table.
    SET SAVE_PATH = CURRENT PATH;
    SET SAVE_SCHEMA = CURRENT SCHEMA;
    FOR C AS
        SELECT
            'SET SCHEMA '  || QUOTE_IDENTIFIER(QUALIFIER)       AS SET_SCHEMA,
            'SET PATH '    || FUNC_PATH                         AS SET_PATH,
            'ALTER TABLE ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE)
                || ' ADD CONSTRAINT ' || QUOTE_IDENTIFIER(CONSTNAME)
                || ' CHECK (' || TEXT || ')'                    AS CREATE_CONST,
            'SET SCHEMA '  || QUOTE_IDENTIFIER(SAVE_SCHEMA)     AS RESTORE_SCHEMA,
            'SET PATH '    || SAVE_PATH                         AS RESTORE_PATH
        FROM
            SYSCAT.CHECKS
        WHERE
            TABSCHEMA = SOURCE_SCHEMA
            AND TABNAME = SOURCE_TABLE
            AND TYPE = 'C'
    DO
        EXECUTE IMMEDIATE C.SET_PATH;
        EXECUTE IMMEDIATE C.SET_SCHEMA;
        EXECUTE IMMEDIATE C.CREATE_CONST;
        EXECUTE IMMEDIATE C.RESTORE_PATH;
        EXECUTE IMMEDIATE C.RESTORE_SCHEMA;
    END FOR;
    -- Store the source table's authorizations, then redirect them to the
    -- destination table filtering out those authorizations which should be
    -- excluded
    CALL SAVE_AUTH(SOURCE_SCHEMA, SOURCE_TABLE);
    UPDATE SAVED_AUTH SET
        TABSCHEMA = DEST_SCHEMA,
        TABNAME = DEST_TABLE,
        DELETEAUTH = 'N',
        INSERTAUTH = 'N',
        UPDATEAUTH = 'N'
    WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE;
    CALL RESTORE_AUTH(DEST_SCHEMA, DEST_TABLE);
    -- Set up comments for the effective and expiry fields then copy the
    -- comments for all fields from the source table
    SET DDL = 'COMMENT ON COLUMN '
        || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE) || '.' || QUOTE_IDENTIFIER(X_HISTORY_EFFNAME(RESOLUTION))
        || ' IS ' || QUOTE_STRING('The date/timestamp from which this row was present in the source table');
    EXECUTE IMMEDIATE DDL;
    SET DDL = 'COMMENT ON COLUMN '
        || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE) || '.' || QUOTE_IDENTIFIER(X_HISTORY_EXPNAME(RESOLUTION))
        || ' IS ' || QUOTE_STRING('The date/timestamp until which this row was present in the source table (rows with 9999-12-31 currently exist in the source table)');
    EXECUTE IMMEDIATE DDL;
    SET DDL = 'COMMENT ON TABLE '
        || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE)
        || ' IS ' || QUOTE_STRING('History table which tracks the content of @' || SOURCE_SCHEMA || '.' || SOURCE_TABLE);
    EXECUTE IMMEDIATE DDL;
    FOR C AS
        SELECT
            VARCHAR('COMMENT ON COLUMN '
                || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_TABLE) || '.' || QUOTE_IDENTIFIER(COLNAME)
                || ' IS ' || QUOTE_STRING(REMARKS)) AS COMMENT_STMT
        FROM SYSCAT.COLUMNS
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        AND REMARKS IS NOT NULL
    DO
        EXECUTE IMMEDIATE C.COMMENT_STMT;
    END FOR;
END!
CREATE OR REPLACE PROCEDURE CREATE_HISTORY_CHANGES(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_VIEW VARCHAR(128)
)
    SPECIFIC CREATE_HISTORY_CHANGES1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE DDL CLOB(64K) DEFAULT '';

    CALL ASSERT_TABLE_EXISTS(SOURCE_SCHEMA, SOURCE_TABLE);
    SET DDL =
        'CREATE VIEW ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_VIEW) || ' AS '
        || X_HISTORY_CHANGES(SOURCE_SCHEMA, SOURCE_TABLE);
    EXECUTE IMMEDIATE DDL;
    -- Store the source table's authorizations, then redirect them to the
    -- destination table filtering out those authorizations which should be
    -- excluded
    CALL SAVE_AUTH(SOURCE_SCHEMA, SOURCE_TABLE);
    UPDATE SAVED_AUTH SET
        TABSCHEMA = DEST_SCHEMA,
        TABNAME = DEST_VIEW,
        DELETEAUTH = 'N',
        INSERTAUTH = 'N',
        UPDATEAUTH = 'N',
        INDEXAUTH = 'N',
        REFAUTH = 'N'
    WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE;
    CALL RESTORE_AUTH(DEST_SCHEMA, DEST_VIEW);
    -- Set up comments for the effective and expiry fields then copy the
    -- comments for all fields from the source table
    SET DDL = 'COMMENT ON COLUMN '
        || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_VIEW) || '.' || QUOTE_IDENTIFIER('CHANGED')
        || ' IS ' || QUOTE_STRING('The date/timestamp on which this row changed');
    EXECUTE IMMEDIATE DDL;
    SET DDL = 'COMMENT ON COLUMN '
        || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_VIEW) || '.' || QUOTE_IDENTIFIER('CHANGE')
        || ' IS ' || QUOTE_STRING('The type of change that occured (INSERT/UPDATE/DELETE)');
    EXECUTE IMMEDIATE DDL;
    SET DDL = 'COMMENT ON TABLE '
        || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_VIEW)
        || ' IS ' || QUOTE_STRING('View showing the content of @' || SOURCE_SCHEMA || '.' || SOURCE_TABLE || ' as a series of changes');
    EXECUTE IMMEDIATE DDL;
    FOR C AS
        SELECT
            VARCHAR('COMMENT ON COLUMN '
                || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_VIEW) || '.' || QUOTE_IDENTIFIER('OLD_' || COLNAME)
                || ' IS ' || QUOTE_STRING('Value of @' || SOURCE_SCHEMA || '.' || SOURCE_TABLE || '.' || COLNAME || ' prior to change')) AS COMMENT_OLD_STMT,
            VARCHAR('COMMENT ON COLUMN '
                || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_VIEW) || '.' || QUOTE_IDENTIFIER('NEW_' || COLNAME)
                || ' IS ' || QUOTE_STRING('Value of @' || SOURCE_SCHEMA || '.' || SOURCE_TABLE || '.' || COLNAME || ' after change')) AS COMMENT_NEW_STMT
        FROM SYSCAT.COLUMNS
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        AND REMARKS IS NOT NULL
        AND COLNO >= 2
    DO
        EXECUTE IMMEDIATE C.COMMENT_OLD_STMT;
        EXECUTE IMMEDIATE C.COMMENT_NEW_STMT;
    END FOR;
END!
CREATE OR REPLACE PROCEDURE CREATE_HISTORY_SNAPSHOTS(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_VIEW VARCHAR(128),
    RESOLUTION VARCHAR(11)
)
    SPECIFIC CREATE_HISTORY_SNAPSHOTS1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE DDL CLOB(64K) DEFAULT '';

    CALL ASSERT_TABLE_EXISTS(SOURCE_SCHEMA, SOURCE_TABLE);
    SET DDL =
        'CREATE VIEW ' || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_VIEW) || ' AS '
        || X_HISTORY_SNAPSHOTS(SOURCE_SCHEMA, SOURCE_TABLE, RESOLUTION);
    EXECUTE IMMEDIATE DDL;
    -- Store the source table's authorizations, then redirect them to the
    -- destination table filtering out those authorizations which should be
    -- excluded
    CALL SAVE_AUTH(SOURCE_SCHEMA, SOURCE_TABLE);
    UPDATE SAVED_AUTH SET
        TABSCHEMA = DEST_SCHEMA,
        TABNAME = DEST_VIEW,
        DELETEAUTH = 'N',
        INSERTAUTH = 'N',
        UPDATEAUTH = 'N',
        INDEXAUTH = 'N',
        REFAUTH = 'N'
    WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE;
    CALL RESTORE_AUTH(DEST_SCHEMA, DEST_VIEW);
    -- Set up comments for the effective and expiry fields then copy the
    -- comments for all fields from the source table
    SET DDL = 'COMMENT ON COLUMN '
        || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_VIEW) || '.' || QUOTE_IDENTIFIER('SNAPSHOT')
        || ' IS ' || QUOTE_STRING('The date/timestamp of this row''s snapshot');
    EXECUTE IMMEDIATE DDL;
    SET DDL = 'COMMENT ON TABLE '
        || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_VIEW)
        || ' IS ' || QUOTE_STRING('View showing the content of @' || SOURCE_SCHEMA || '.' || SOURCE_TABLE || ' as a series of snapshots');
    EXECUTE IMMEDIATE DDL;
    FOR C AS
        SELECT
            VARCHAR('COMMENT ON COLUMN '
                || QUOTE_IDENTIFIER(DEST_SCHEMA) || '.' || QUOTE_IDENTIFIER(DEST_VIEW) || '.' || QUOTE_IDENTIFIER('OLD_' || COLNAME)
                || ' IS ' || QUOTE_STRING('Value of @' || SOURCE_SCHEMA || '.' || SOURCE_TABLE || '.' || COLNAME || ' at the time of the snapshot')) AS COMMENT_STMT
        FROM SYSCAT.COLUMNS
        WHERE TABSCHEMA = SOURCE_SCHEMA
        AND TABNAME = SOURCE_TABLE
        AND REMARKS IS NOT NULL
        AND COLNO >= 2
    DO
        EXECUTE IMMEDIATE C.COMMENT_STMT;
    END FOR;
END!
CREATE OR REPLACE PROCEDURE CREATE_HISTORY_TRIGGERS(
    SOURCE_SCHEMA VARCHAR(128),
    SOURCE_TABLE VARCHAR(128),
    DEST_SCHEMA VARCHAR(128),
    DEST_TABLE VARCHAR(128),
    RESOLUTION VARCHAR(11),
    OFFSET VARCHAR(100)
)
    SPECIFIC CREATE_HISTORY_TRIGGERS1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE DDL CLOB(64K) DEFAULT '';

    CALL ASSERT_TABLE_EXISTS(SOURCE_SCHEMA, SOURCE_TABLE);
    CALL ASSERT_TABLE_EXISTS(DEST_SCHEMA, DEST_TABLE);
    -- Drop any existing triggers with the same name as the destination
    -- triggers
    FOR D AS
        SELECT
            'DROP TRIGGER ' || QUOTE_IDENTIFIER(TRIGSCHEMA) || '.' || QUOTE_IDENTIFIER(TRIGNAME) AS DROP_CMD
        FROM
            SYSCAT.TRIGGERS
        WHERE
            TABSCHEMA = SOURCE_SCHEMA
            AND TABNAME = SOURCE_TABLE
            AND TRIGSCHEMA = SOURCE_SCHEMA
            AND TRIGNAME IN (
                SOURCE_TABLE || '_KEYCHG',
                SOURCE_TABLE || '_INSERT',
                SOURCE_TABLE || '_UPDATE',
                SOURCE_TABLE || '_DELETE'
            )
    DO
        EXECUTE IMMEDIATE D.DROP_CMD;
    END FOR;
    -- Create the KEYCHG trigger
    SET DDL =
        'CREATE TRIGGER ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE || '_KEYCHG')
        || '    NO CASCADE BEFORE UPDATE OF '
        ||          X_HISTORY_UPDATE_FIELDS(SOURCE_SCHEMA, SOURCE_TABLE, CHAR('Y'))
        || '    ON ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE)
        || '    REFERENCING OLD AS OLD NEW AS NEW'
        || '    FOR EACH ROW '
        || 'WHEN ('
        ||      X_HISTORY_UPDATE_WHEN(SOURCE_SCHEMA, SOURCE_TABLE, CHAR('Y'))
        || ') '
        || 'BEGIN ATOMIC'
        || '    CALL SIGNAL_STATE(HISTORY_UPDATE_PK_STATE,'
        || '        ''Cannot update unique key of a ' || REPLACE(QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE), '''', '''''') || ' row''); '
        || 'END';
    EXECUTE IMMEDIATE DDL;
    -- Create the INSERT trigger
    SET DDL =
        'CREATE TRIGGER ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE || '_INSERT')
        || '    AFTER INSERT ON ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE)
        || '    REFERENCING NEW AS NEW'
        || '    FOR EACH ROW '
        || 'BEGIN ATOMIC '
        ||      X_HISTORY_INSERT(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, RESOLUTION, OFFSET) || ';'
        || 'END';
    EXECUTE IMMEDIATE DDL;
    -- Create the UPDATE trigger
    SET DDL =
        'CREATE TRIGGER ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE || '_UPDATE')
        || '    AFTER UPDATE OF '
        ||          X_HISTORY_UPDATE_FIELDS(SOURCE_SCHEMA, SOURCE_TABLE, CHAR('N'))
        || '    ON ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE)
        || '    REFERENCING OLD AS OLD NEW AS NEW'
        || '    FOR EACH ROW '
        || 'WHEN ('
        ||      X_HISTORY_UPDATE_WHEN(SOURCE_SCHEMA, SOURCE_TABLE, CHAR('N'))
        || ') '
        || 'BEGIN ATOMIC'
        || '    DECLARE CHK_DATE DATE;'
        || '    SET CHK_DATE = ('
        ||          X_HISTORY_CHECK(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, RESOLUTION)
        || '    );'
        || '    IF ' || X_HISTORY_EFFNEXT(RESOLUTION, OFFSET) || ' > CHK_DATE THEN '
        ||          X_HISTORY_EXPIRE(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, RESOLUTION, OFFSET) || ';'
        ||          X_HISTORY_INSERT(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, RESOLUTION, OFFSET) || ';'
        || '    ELSE '
        ||          X_HISTORY_UPDATE(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, RESOLUTION) || ';'
        || '    END IF; '
        || 'END';
    EXECUTE IMMEDIATE DDL;
    -- Create the DELETE trigger
    SET DDL =
        'CREATE TRIGGER ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE || '_DELETE')
        || '    AFTER DELETE ON ' || QUOTE_IDENTIFIER(SOURCE_SCHEMA) || '.' || QUOTE_IDENTIFIER(SOURCE_TABLE)
        || '    REFERENCING OLD AS OLD'
        || '    FOR EACH ROW '
        || 'BEGIN ATOMIC'
        || '    DECLARE CHK_DATE DATE;'
        || '    SET CHK_DATE = ('
        ||          X_HISTORY_CHECK(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, RESOLUTION)
        || '    );'
        || '    IF ' || X_HISTORY_EFFNEXT(RESOLUTION, OFFSET) || ' > CHK_DATE THEN '
        ||          X_HISTORY_EXPIRE(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, RESOLUTION, OFFSET) || ';'
        || '    ELSE '
        ||          X_HISTORY_DELETE(SOURCE_SCHEMA, SOURCE_TABLE, DEST_SCHEMA, DEST_TABLE, RESOLUTION) || ';'
        || '    END IF; '
        || 'END';
    EXECUTE IMMEDIATE DDL;
END!
CREATE OR REPLACE PROCEDURE DISABLE_TRIGGER(ASCHEMA VARCHAR(128), ATRIGGER VARCHAR(128))
    SPECIFIC DISABLE_TRIGGER1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE SQLCODE INTEGER DEFAULT 0;
    DECLARE EXIT HANDLER FOR NOT FOUND
        CALL SIGNAL_STATE(TRIGGER_NOT_FOUND_STATE, 'Trigger not found');
    DECLARE EXIT HANDLER FOR SQLWARNING
        CALL SIGNAL_STATE(TRIGGER_NOT_DISABLED_STATE, 'Unable to disable trigger');
    -- Copy the trigger's entry from SYSCAT.TRIGGERS to DISABLED_TRIGGERS
    INSERT INTO DISABLED_TRIGGERS
        SELECT
            TRIGSCHEMA,
            TRIGNAME,
            TABSCHEMA,
            TABNAME,
            QUALIFIER,
            FUNC_PATH,
            TEXT
        FROM
            SYSCAT.TRIGGERS
        WHERE
            TRIGSCHEMA = ASCHEMA
            AND TRIGNAME = ATRIGGER
            AND VALID = 'Y';
    -- Drop the trigger
    FOR D AS
        SELECT DDL
        FROM (
            VALUES 'DROP TRIGGER ' || QUOTE_IDENTIFIER(ASCHEMA) || '.' || QUOTE_IDENTIFIER(ATRIGGER)
        ) AS D(DDL)
    DO
        EXECUTE IMMEDIATE D.DDL;
    END FOR;
END!
CREATE OR REPLACE PROCEDURE DISABLE_TRIGGERS(ASCHEMA VARCHAR(128), ATABLE VARCHAR(128))
    SPECIFIC DISABLE_TRIGGERS1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE SQLCODE INTEGER DEFAULT 0;
    DECLARE EXIT HANDLER FOR NOT FOUND
        CALL SIGNAL_STATE(TRIGGER_NOT_FOUND_STATE, 'Trigger not found');
    DECLARE EXIT HANDLER FOR SQLWARNING
        CALL SIGNAL_STATE(TRIGGER_NOT_DISABLED_STATE, 'Unable to disable trigger');
    -- Copy all of ATABLE's triggers from SYSCAT.TRIGGERS to DISABLED_TRIGGERS
    INSERT INTO DISABLED_TRIGGERS
        SELECT
            TRIGSCHEMA,
            TRIGNAME,
            TABSCHEMA,
            TABNAME,
            QUALIFIER,
            FUNC_PATH,
            TEXT
        FROM
            SYSCAT.TRIGGERS
        WHERE
            TABSCHEMA = ASCHEMA
            AND TABNAME = ATABLE
            AND VALID = 'Y';
    -- Drop the triggers
    FOR D AS
        SELECT
            'DROP TRIGGER ' || QUOTE_IDENTIFIER(TRIGSCHEMA) || '.' || QUOTE_IDENTIFIER(TRIGNAME) AS DDL
        FROM
            SYSCAT.TRIGGERS
        WHERE
            TABSCHEMA = ASCHEMA
            AND TABNAME = ATABLE
            AND VALID = 'Y'
    DO
        EXECUTE IMMEDIATE D.DDL;
    END FOR;
END!
CREATE OR REPLACE PROCEDURE ENABLE_TRIGGER(ASCHEMA VARCHAR(128), ATRIGGER VARCHAR(128))
    SPECIFIC ENABLE_TRIGGER1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE SQLCODE INTEGER DEFAULT 0;
    DECLARE SAVE_PATH VARCHAR(254);
    DECLARE SAVE_SCHEMA VARCHAR(128);
    DECLARE EXIT HANDLER FOR SQLWARNING
        CALL SIGNAL_STATE(TRIGGER_NOT_ENABLED_STATE, 'Unable to enable trigger');
    -- Save the current function resolution path and implicit schema for later
    -- restoration
    SET SAVE_PATH = CURRENT PATH;
    SET SAVE_SCHEMA = CURRENT SCHEMA;
    -- Change the current schema and path to those that were used when the
    -- trigger was created and recreate the trigger
    FOR D AS
        SELECT
            'SET SCHEMA ' || QUOTE_IDENTIFIER(QUALIFIER)   AS SET_QUALIFIER,
            'SET PATH '   || FUNC_PATH                     AS SET_PATH,
            TEXT                                           AS TEXT,
            'SET SCHEMA ' || QUOTE_IDENTIFIER(SAVE_SCHEMA) AS RESTORE_QUALIFIER,
            'SET PATH '   || SAVE_PATH                     AS RESTORE_PATH
        FROM
            DISABLED_TRIGGERS
        WHERE
            TRIGSCHEMA = ASCHEMA
            AND TRIGNAME = ATRIGGER
    DO
        EXECUTE IMMEDIATE D.SET_PATH;
        EXECUTE IMMEDIATE D.SET_QUALIFIER;
        EXECUTE IMMEDIATE D.TEXT;
        EXECUTE IMMEDIATE D.RESTORE_QUALIFIER;
        EXECUTE IMMEDIATE D.RESTORE_PATH;
    END FOR;
    -- Remove the entry from DISABLED_TRIGGERS
    DELETE FROM DISABLED_TRIGGERS
        WHERE TRIGSCHEMA = ASCHEMA AND TRIGNAME = ATRIGGER;
END!
CREATE OR REPLACE PROCEDURE ENABLE_TRIGGERS(ASCHEMA VARCHAR(128), ATABLE VARCHAR(128))
    SPECIFIC ENABLE_TRIGGERS1
    MODIFIES SQL DATA
    NOT DETERMINISTIC
    NO EXTERNAL ACTION
    LANGUAGE SQL
BEGIN ATOMIC
    DECLARE SQLCODE INTEGER DEFAULT 0;
    DECLARE SAVE_PATH VARCHAR(254);
    DECLARE SAVE_SCHEMA VARCHAR(128);
    DECLARE EXIT HANDLER FOR SQLWARNING
        CALL SIGNAL_STATE(TRIGGER_NOT_ENABLED_STATE, 'Unable to enable trigger');
    -- Save the current function resolution path and implicit schema for later
    -- restoration
    SET SAVE_PATH = CURRENT PATH;
    SET SAVE_SCHEMA = CURRENT SCHEMA;
    -- Change the current schema and path to those that were used when the
    -- triggers were created and recreate the triggers
    FOR D AS
        SELECT
            'SET SCHEMA ' || QUOTE_IDENTIFIER(QUALIFIER)   AS SET_QUALIFIER,
            'SET PATH '   || FUNC_PATH                     AS SET_PATH,
            TEXT                                           AS TEXT,
            'SET SCHEMA ' || QUOTE_IDENTIFIER(SAVE_SCHEMA) AS RESTORE_QUALIFIER,
            'SET PATH '   || SAVE_PATH                     AS RESTORE_PATH
        FROM
            DISABLED_TRIGGERS
        WHERE
            TABSCHEMA = ASCHEMA
            AND TABNAME = ATABLE
    DO
        EXECUTE IMMEDIATE D.SET_PATH;
        EXECUTE IMMEDIATE D.SET_QUALIFIER;
        EXECUTE IMMEDIATE D.TEXT;
        EXECUTE IMMEDIATE D.RESTORE_QUALIFIER;
        EXECUTE IMMEDIATE D.RESTORE_PATH;
    END FOR;
    -- Remove the entries from DISABLED_TRIGGERS
    DELETE FROM DISABLED_TRIGGERS
        WHERE TABSCHEMA = ASCHEMA AND TABNAME = ATABLE;
END!
DROP SPECIFIC FUNCTION COPY$LIST!
DROP SPECIFIC FUNCTION REMOVE$LIST!
DROP ROLE LOG_ADMIN!
DROP ROLE LOG_READER!
DROP ROLE LOG_WRITER!
REVOKE CONTROL ON LOG FROM ROLE LOG_ADMIN!
REVOKE SELECT ON LOG FROM ROLE LOG_READER!
REVOKE INSERT ON LOG FROM ROLE LOG_WRITER!
DROP SPECIFIC FUNCTION TS$PAD!
DROP SPECIFIC FUNCTION TS$FMT!
DROP SPECIFIC FUNCTION WORKINGDAY$DAY!
DROP SPECIFIC FUNCTION WORKINGDAY$SDOW!
DROP SPECIFIC FUNCTION DROP$LIST!
DROP SPECIFIC FUNCTION HISTORY$EFFNAME1!
DROP SPECIFIC FUNCTION HISTORY$EFFNAME2!
DROP SPECIFIC FUNCTION HISTORY$EXPNAME1!
DROP SPECIFIC FUNCTION HISTORY$EXPNAME2!
DROP SPECIFIC FUNCTION HISTORY$EFFDEFAULT1!
DROP SPECIFIC FUNCTION HISTORY$EFFDEFAULT2!
DROP SPECIFIC FUNCTION HISTORY$EXPDEFAULT1!
DROP SPECIFIC FUNCTION HISTORY$EXPDEFAULT2!
DROP SPECIFIC FUNCTION HISTORY$PERIODSTART!
DROP SPECIFIC FUNCTION HISTORY$PERIODEND!
DROP SPECIFIC FUNCTION HISTORY$PERIODLEN!
DROP SPECIFIC FUNCTION HISTORY$PERIODSTEP1!
DROP SPECIFIC FUNCTION HISTORY$PERIODSTEP2!
DROP SPECIFIC FUNCTION HISTORY$EFFNEXT!
DROP SPECIFIC FUNCTION HISTORY$EXPPRIOR!
DROP SPECIFIC FUNCTION HISTORY$INSERT!
DROP SPECIFIC FUNCTION HISTORY$EXPIRE!
DROP SPECIFIC FUNCTION HISTORY$UPDATE!
DROP SPECIFIC FUNCTION HISTORY$DELETE!
DROP SPECIFIC FUNCTION HISTORY$CHECK!
DROP SPECIFIC FUNCTION HISTORY$CHANGES!
DROP SPECIFIC FUNCTION HISTORY$SNAPSHOTS!
DROP SPECIFIC FUNCTION HISTORY$UPDATE_FIELDS!
DROP SPECIFIC FUNCTION HISTORY$UPDATE_WHEN!
COMMIT!
